[
  {
    "url": "https://ipranavbansal.medium.com/python-and-its-libraries-under-5-mins-4dea5c9b0bbc",
    "title": "Python basics | Under 5 mins",
    "author": "Press",
    "published_date": null,
    "reading_time": "3 min read",
    "tags": [
      "Python",
      "Numpy",
      "Tech",
      "Data Analysis",
      "Interview"
    ],
    "content": [
      {
        "type": "h1",
        "content": "Python basics | Under 5 mins"
      },
      {
        "type": "h2",
        "content": "Trying to simplify the basic Python concepts for beginners."
      },
      {
        "type": "p",
        "content": "Pranav Bansal"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "h1",
        "content": "History"
      },
      {
        "type": "h1",
        "content": "Why Python is created?"
      },
      {
        "type": "h2",
        "content": "PROS"
      },
      {
        "type": "h2",
        "content": "CONS"
      },
      {
        "type": "h1",
        "content": "How code is interpreted? Why Python is platform Independent?"
      },
      {
        "type": "p",
        "content": "Source code > Compiler > compiled code/machine code > Ready to Run"
      },
      {
        "type": "h2",
        "content": "Problem -"
      },
      {
        "type": "p",
        "content": "Source Code > Interpreter >Byte Code > Ready to Run"
      },
      {
        "type": "h1",
        "content": "Use case -"
      },
      {
        "type": "p",
        "content": "Being a general-purpose language,Python can be used to -"
      },
      {
        "type": "h1",
        "content": "Libraries"
      },
      {
        "type": "p",
        "content": "What is a library in programming?"
      },
      {
        "type": "p",
        "content": "Python comes with a set of standard libraries, which can be referred to as base Python."
      },
      {
        "type": "p",
        "content": "Python also has a lot of external libraries like -"
      },
      {
        "type": "p",
        "content": "and much more."
      },
      {
        "type": "h1",
        "content": "Software Distribution."
      },
      {
        "type": "h2",
        "content": "Anaconda"
      },
      {
        "type": "h2",
        "content": "Distribution"
      },
      {
        "type": "p",
        "content": "Software distribution is the process of delivering software to the end user."
      },
      {
        "type": "h2",
        "content": "Jupyter notebook"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:10.748757"
  },
  {
    "url": "https://medium.com/python-tutorial/what-is-python-and-whats-makes-it-so-famous-b91c9b938293",
    "title": "What is python and what‚Äôs makes it so famous",
    "author": "",
    "published_date": null,
    "reading_time": "2 min read",
    "tags": [
      "Programming",
      "Python Tutorial",
      "Interpreters",
      "Tutoriales"
    ],
    "content": [
      {
        "type": "h1",
        "content": "What is python and what‚Äôs makes it so famous"
      },
      {
        "type": "p",
        "content": "H@rsh Kumar"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "Python tutorial"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "h1",
        "content": "# Firstly, What is Python (Reptiles or else)"
      },
      {
        "type": "blockquote",
        "content": "Python ,is obvious not a snake. It‚Äôs a high level programming language."
      },
      {
        "type": "p",
        "content": "Python ,is obvious not a snake. It‚Äôs a high level programming language."
      },
      {
        "type": "p",
        "content": "The language is named after the BBC show ‚ÄúMonty Python‚Äôs Flying Circus‚Äù and has nothing to do with reptiles."
      },
      {
        "type": "p",
        "content": "Python is simple to use, but it is a real programming language, offering much more structure and support for large programs than shell scripts or batch files can offer. On the other hand, Python also offers much more error checking than C, and, being a very-high-level language, it has high-level data types built in, such as flexible arrays and dictionaries."
      },
      {
        "type": "p",
        "content": "Python allows you to split your program into modules that can be reused in other Python programs. Examples : Some modules provide things like file I/O, system calls, sockets, and even interfaces to graphical user interface toolkits like Tk( If you don‚Äôt know it‚Äôs ok, we will cover all those in coming topics)."
      },
      {
        "type": "h1",
        "content": "# Python is an interpreted language"
      },
      {
        "type": "p",
        "content": "Q. What is an interpreted language?"
      },
      {
        "type": "p",
        "content": "An interpreted language is a type of programming language for which most of its implementations execute instructions directly and freely, without previously compiling a program into machine-language instructions. The interpreter executes the program directly, translating each statement into a sequence of one or more subroutines already compiled into machine code."
      },
      {
        "type": "p",
        "content": "Python enables programs to be written compactly and readably. Programs written in Python are typically much shorter than equivalent C, C++, or Java programs, for several reasons:"
      },
      {
        "type": "h1",
        "content": "# Python is extensible"
      },
      {
        "type": "p",
        "content": "If you know how to program in C it is easy to add a new built-in function or module to the interpreter, either to perform critical operations at maximum speed, or to link Python programs to libraries that may only be available in binary form . Once you are really hooked, you can link the Python interpreter into an application written in C and use it as an extension or command language for that application."
      },
      {
        "type": "p",
        "content": "Now that you are all excited about Python, we‚Äôll take you to the zero level to top. Just hook up for upcoming chapters."
      },
      {
        "type": "blockquote",
        "content": "The best way to learn a language is to use it, so as you go through the course keep your editor ready and code together to catch more details about the language. (Next, i will help you to install python and which code editor to use)."
      },
      {
        "type": "p",
        "content": "The best way to learn a language is to use it, so as you go through the course keep your editor ready and code together to catch more details about the language. (Next, i will help you to install python and which code editor to use)."
      },
      {
        "type": "p",
        "content": "Happy Coding </>"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:12.872173"
  },
  {
    "url": "https://medium.com/python-tutorial/python-installation-and-ide-selection-ab80bfa17d23",
    "title": "Python installation and IDE selection",
    "author": "",
    "published_date": null,
    "reading_time": "2 min read",
    "tags": [
      "Programming",
      "Python Installing",
      "Python",
      "Features"
    ],
    "content": [
      {
        "type": "h1",
        "content": "Python installation and IDE selection"
      },
      {
        "type": "p",
        "content": "H@rsh Kumar"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "Python tutorial"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "h1",
        "content": "# Installation Process"
      },
      {
        "type": "p",
        "content": "In this tutorial we will cover the installation process for different operating system like Windows , mac and linux."
      },
      {
        "type": "p",
        "content": "For installing python you have to download the software from the official site of python."
      },
      {
        "type": "h1",
        "content": "# IDE selection"
      },
      {
        "type": "blockquote",
        "content": "IDE stands for Integrated Development Environments is the most truly friend for any programmer. Good IDE help the programmer to write codes faster and cleaner."
      },
      {
        "type": "p",
        "content": "IDE stands for Integrated Development Environments is the most truly friend for any programmer. Good IDE help the programmer to write codes faster and cleaner."
      },
      {
        "type": "p",
        "content": "For python there are several IDE available and choosing among them is more confusing part of learning. So , to get the perfect IDE for your development depends on the operating system you are working on. Here i have provided the best IDE s for different operating systems."
      },
      {
        "type": "p",
        "content": "2. For Mac Users :"
      },
      {
        "type": "p",
        "content": "3. For Linux Users :"
      },
      {
        "type": "h1",
        "content": "# Features of Python"
      },
      {
        "type": "p",
        "content": "Some of Python‚Äôs notable features:"
      },
      {
        "type": "p",
        "content": "That‚Äôs all for this module. In the next module we get our hands dirty with code by writing small programs."
      },
      {
        "type": "p",
        "content": "Till now Happy Coding‚Ä¶ </>"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:14.996630"
  },
  {
    "url": "https://cloudmize.medium.com/python-programming-essentials-from-beginner-to-pro-8a6860cbf586",
    "title": "Python Programming Essentials: From Beginner to Pro",
    "author": "Press",
    "published_date": null,
    "reading_time": "5 min read",
    "tags": [],
    "content": [
      {
        "type": "p",
        "content": "Member-only story"
      },
      {
        "type": "h1",
        "content": "Python Programming Essentials: From Beginner to Pro"
      },
      {
        "type": "h2",
        "content": "Your journey from Python novice to coding expert starts here"
      },
      {
        "type": "p",
        "content": "Usman Aslam"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "Let me take you on a personal journey through the world of Python programming."
      },
      {
        "type": "p",
        "content": "If you‚Äôre reading this, you‚Äôre probably intrigued by the idea of mastering Python, the language that has captured the hearts of programmers, data scientists, and tech enthusiasts worldwide."
      },
      {
        "type": "p",
        "content": "And if you‚Äôre just starting, don‚Äôt worry; everyone begins as a novice. I was there too, once."
      },
      {
        "type": "p",
        "content": "I‚Äôve been teaching Python to my 10-year-old son for the last few months and he is currently at the intermediate level. If a 10-year-old can learn Python, imagine what you can achieve!"
      },
      {
        "type": "p",
        "content": "Did you know that Python is so popular that it‚Äôs been the fastest-growing major programming language for several years, with an astounding 27% increase in usage in just one year?"
      },
      {
        "type": "p",
        "content": "If that doesn‚Äôt pique your interest, I don‚Äôt know what will. Python‚Äôs rise to fame isn‚Äôt a fluke; it‚Äôs a testament to its power and versatility."
      },
      {
        "type": "blockquote",
        "content": "Feel free to explore and save the curated lists included at the end of this story. Follow me for future stories and subscribe for email updates."
      },
      {
        "type": "p",
        "content": "Feel free to explore and save the curated lists included at the end of this story. Follow me for future stories and subscribe for email updates."
      },
      {
        "type": "p",
        "content": "Let‚Äôs cut to the chase and dive right in, shall we?"
      },
      {
        "type": "h2",
        "content": "Mastering the Art of Programming: Tips and Tricks"
      },
      {
        "type": "h3",
        "content": "Level up your coding game with expert programming advice"
      },
      {
        "type": "p",
        "content": "cloudmize.medium.com"
      },
      {
        "type": "h1",
        "content": "The Unexpected Simplicity of Python"
      },
      {
        "type": "p",
        "content": "Picture this: you‚Äôre standing at the entrance of a vast maze, representing the world of programming languages."
      },
      {
        "type": "p",
        "content": "Python, however, is no labyrinth; it‚Äôs a well-lit, inviting path."
      },
      {
        "type": "p",
        "content": "One of the most striking revelations about Python is its sheer simplicity."
      },
      {
        "type": "p",
        "content": "Its readable syntax and straightforward structure make it not only easy to learn but also a joy to work with."
      },
      {
        "type": "p",
        "content": "In a world often plagued by complexity, Python stands as a beacon of clarity."
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:17.364536"
  },
  {
    "url": "https://medium.com/%40patelharshali136/python-tutorial-for-beginners-introduction-to-python-a79db6921da4",
    "title": "Python Tutorial for Beginners ‚Äî Introduction to Python",
    "author": "",
    "published_date": null,
    "reading_time": "6 min read",
    "tags": [
      "Python"
    ],
    "content": [
      {
        "type": "h1",
        "content": "Python Tutorial for Beginners ‚Äî Introduction to Python"
      },
      {
        "type": "p",
        "content": "Harshali Patel"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "h1",
        "content": "1. Python Tutorial"
      },
      {
        "type": "p",
        "content": "In this Python tutorial, we will learn about the introduction to Python programming, Python features, an overview of Python architecture, and Python applications in real industry. We will also learn about available python frameworks like Django, Flask, Pyramid etc."
      },
      {
        "type": "p",
        "content": "The transition from consuming games and web apps to being the one behind them is exciting. Imagine if, with one technology, you could create all that? The world would be at your fingertips. Well, what if we told you that it‚Äôs possible? 1991 changed a lot of things for the programming industry and many others. We‚Äôre talking about Python programming, a friendly general-purpose programming language. And in a world of machine learning, Python is here to stay. So let us start with Python tutorial."
      },
      {
        "type": "p",
        "content": "Python Tutorial"
      },
      {
        "type": "h1",
        "content": "2. Python Tutorial ‚Äî What is Python?"
      },
      {
        "type": "p",
        "content": "Let us start this python tutorial with ‚ÄòWhat is Python?‚Äô"
      },
      {
        "type": "p",
        "content": "Python is an object-oriented language, which means that it can model real-world objects. It is also dynamically-typed because it carries out type-checking at runtime. It does so to make sure that the type of a construct matches what we expect in that context. The distinctive feature about Python is that it is an interpreted language. The Python IDLE (Integrated DeveLopment Environment) executes instructions a line at a time."
      },
      {
        "type": "p",
        "content": "Etymology states that Guido van Rossum named it after the comedy group Monty Python. That is why the metasyntactic variables used here are ‚Äòspam‚Äô and ‚Äòeggs‚Äô instead of ‚Äòfoo‚Äô and ‚Äòbar‚Äô. Unlike as expected, it does not refer to the reptile species. A lot of implementations today run version 2.x, but the future belongs to Python 3.x. It is also called ‚ÄòPython 3000‚Äô or ‚ÄòPy3K‚Äô. CPython, written in C, is the most common implementation of Python. It compiles a Python program into intermediate bytecode."
      },
      {
        "type": "p",
        "content": "Apart from the constructs that Python provides, you can use the PyPI (Python Package Index). It is a repository of third-party modules, you can install it using a program called pip. Run the following command in Command Prompt:"
      },
      {
        "type": "p",
        "content": "pip install library_name"
      },
      {
        "type": "p",
        "content": "Python or R: To learn the difference between Python and R, please follow Python vs R. For now let is move ahead with the current python tutorial."
      },
      {
        "type": "h1",
        "content": "3. Python History"
      },
      {
        "type": "p",
        "content": "Python programming language was conceived in the late 1980s and was named for the BBC TV show Monty Python‚Äôs Flying Circus. Guido van Rossum started python implementation at CWI in the Netherlands in December 1989. This was a successor to the ABC (programming language) which was capable of exception handling and interfacing with the Amoeba operating system."
      },
      {
        "type": "p",
        "content": "On October 16, 2000, python 2.0 release was there and it had many major new features, that includes cycle-detecting garbage collector for memory management and support for Unicode."
      },
      {
        "type": "p",
        "content": "Next version of Python 3.0 was released on December 3, 2008."
      },
      {
        "type": "p",
        "content": "Now we know how Python came to the picture. Now let us jump to the Python Architecture in this Python Tutorial."
      },
      {
        "type": "h1",
        "content": "4. Architecture"
      },
      {
        "type": "p",
        "content": "This is the architecture of a CPython Compiler/Interpreter."
      },
      {
        "type": "p",
        "content": "a. Parser"
      },
      {
        "type": "p",
        "content": "It uses the source code to generate an abstract syntax tree."
      },
      {
        "type": "p",
        "content": "b. Compiler"
      },
      {
        "type": "p",
        "content": "It turns the abstract syntax tree into Python byte code."
      },
      {
        "type": "p",
        "content": "c. Interpreter"
      },
      {
        "type": "p",
        "content": "It executes the code line by line."
      },
      {
        "type": "p",
        "content": "In the below topic of python tutorial, we will cover the components of python programming language."
      },
      {
        "type": "h1",
        "content": "5. Components of Python"
      },
      {
        "type": "h1",
        "content": "a. Functions"
      },
      {
        "type": "p",
        "content": "A function is a collection of statements named into one. You can use it when you want to execute all those statements at a time. You can call it wherever you want in a program. A function may return a value."
      },
      {
        "type": "h1",
        "content": "b. Classes"
      },
      {
        "type": "p",
        "content": "As we discussed, Python is an object-oriented language. It supports classes and objects. A class is an abstract data type. In other words, it is a blueprint for an object of a certain kind. It holds no values."
      },
      {
        "type": "h1",
        "content": "c. Modules"
      },
      {
        "type": "p",
        "content": "A Python module is a collection of related classes and functions. We have modules for mathematical calculations, string manipulations, web programming, and many more."
      },
      {
        "type": "h1",
        "content": "d. Packages"
      },
      {
        "type": "p",
        "content": "A package is a collection of related modules. You can either import a package or create your own."
      },
      {
        "type": "p",
        "content": "Now let us learn about the features of Python in this python tutorial. Based on these features you will be able to choose a programming language for your new project."
      },
      {
        "type": "h1",
        "content": "6. Features of Python"
      },
      {
        "type": "p",
        "content": "Python is one of the richest language, in this python tutorial we will discuss several features of python:"
      },
      {
        "type": "p",
        "content": "Python Tutorial ‚Äî Features of Python"
      },
      {
        "type": "p",
        "content": "a. Easy"
      },
      {
        "type": "p",
        "content": "Python is very easy to learn and understand, using this python tutorial any beginner can understand basics of python."
      },
      {
        "type": "p",
        "content": "b. Interpreted"
      },
      {
        "type": "p",
        "content": "It is interpreted(executed) line by line. This makes it easy to test and debug."
      },
      {
        "type": "p",
        "content": "c. Object-Oriented"
      },
      {
        "type": "p",
        "content": "It supports classes and objects."
      },
      {
        "type": "p",
        "content": "d. Free and Open Source"
      },
      {
        "type": "p",
        "content": "The language and its source code are available to the public for free, no need to buy a costly license."
      },
      {
        "type": "p",
        "content": "e. Portable"
      },
      {
        "type": "p",
        "content": "You can run Python on Windows, Mac, Linux or any other platform."
      },
      {
        "type": "p",
        "content": "f. GUI Programming"
      },
      {
        "type": "p",
        "content": "You can use it to develop a Graphical User Interface."
      },
      {
        "type": "p",
        "content": "g. Large Library"
      },
      {
        "type": "p",
        "content": "Python provides you with a large standard library. You can use it to implement a variety of functions."
      },
      {
        "type": "p",
        "content": "Read more about the features of Python in Detail in another of out Python tutorial on features of Python."
      },
      {
        "type": "p",
        "content": "Now in This Python Tutorial let us see the Frameworks available in Python."
      },
      {
        "type": "h1",
        "content": "7. Frameworks available in Python"
      },
      {
        "type": "p",
        "content": "Python Tutorial ‚Äî Python Frameworks"
      },
      {
        "type": "h1",
        "content": "a. Django"
      },
      {
        "type": "p",
        "content": "This is a free and open-source framework that was written in Python and is the most common framework for Python. It allows you to create database-driven websites. It follows the DRY Principle (Don‚Äôt Repeat Yourself). Popular websites like Instagram, Mozilla, and Disqus make use of it."
      },
      {
        "type": "h1",
        "content": "b. Flask"
      },
      {
        "type": "p",
        "content": "Like Django, Flask is a web framework written in Python. It is a micro framework because it does not need certain libraries and tools. It also does not have form validation or a database abstraction layer. However, you can make use of extensions to add extra features."
      },
      {
        "type": "h1",
        "content": "c. Pyramid"
      },
      {
        "type": "p",
        "content": "Pyramid is another web framework. It is neither a mega-framework that would make decisions for you nor a micro-framework that wouldn‚Äôt force decisions. It gives you optimal liberty on your project."
      },
      {
        "type": "h1",
        "content": "d. Tornado"
      },
      {
        "type": "p",
        "content": "Another open-source web framework, it was written in Python. It is noted for its excellent performance and scalability."
      },
      {
        "type": "h1",
        "content": "e. Bottle"
      },
      {
        "type": "p",
        "content": "Like Flask, it is a micro-framework for Python. It is used for web development. Bottle is known for its speed, simplicity, and light-weight. A single file can run both Python 2.5+ and 3.x"
      },
      {
        "type": "h1",
        "content": "f. web2py"
      },
      {
        "type": "p",
        "content": "Written in Python, web2py is another open source web framework. It emphasizes on rapid development, and follows an MVC architecture. MVC stands for Model View Controller."
      },
      {
        "type": "h1",
        "content": "g. NumPy"
      },
      {
        "type": "p",
        "content": "NumPy is an open-source framework for Python. It is used for scientific computing. It supports large multidimensional arrays and matrices, and functions to operate on them."
      },
      {
        "type": "h1",
        "content": "h. SciPy"
      },
      {
        "type": "p",
        "content": "SciPy is a Python library that you can use for scientific computing. It has modules for linear algebra, interpolation, fast Fourier transform, image processing, and many more. It uses a multidimensional array from the NumPy module."
      },
      {
        "type": "h1",
        "content": "i. Pylons"
      },
      {
        "type": "p",
        "content": "This is a deprecated framework, which means it is no longer recommended. It is a web framework, and is open source as well. It makes extensive use of third-party tools."
      },
      {
        "type": "p",
        "content": "Next chapter in the Python tutorial is the different Flavors of Python."
      },
      {
        "type": "p",
        "content": "Read: Python Variables and Data Types"
      },
      {
        "type": "h1",
        "content": "8. Flavors of Python"
      },
      {
        "type": "p",
        "content": "Python Tutorial ‚Äî Python Flavors types"
      },
      {
        "type": "h1",
        "content": "a. CPython"
      },
      {
        "type": "p",
        "content": "This is the most widely accepted implementation of Python. It is written in the language C, and is an interpreter."
      },
      {
        "type": "h1",
        "content": "b. Jython"
      },
      {
        "type": "p",
        "content": "Jython is a Python implementation written in Java. A Jython program can import any Java class. It compiles to Java bytecode."
      },
      {
        "type": "h1",
        "content": "Continue Reading on original Python Tutorial by Dataflair>>"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:19.475430"
  },
  {
    "url": "https://medium.",
    "error": "HTTPSConnectionPool(host='medium.', port=443): Max retries exceeded with url: / (Caused by NameResolutionError(\"<urllib3.connection.HTTPSConnection object at 0x777cf3c74740>: Failed to resolve 'medium' ([Errno -2] Name or service not known)\"))",
    "scraped_at": "2025-03-30T01:59:21.480923"
  },
  {
    "url": "datadriveninvestor.com/learning-python-for-data-science-in-5-steps-76e96df6f0b1",
    "error": "Invalid URL 'datadriveninvestor.com/learning-python-for-data-science-in-5-steps-76e96df6f0b1': No scheme supplied. Perhaps you meant https://datadriveninvestor.com/learning-python-for-data-science-in-5-steps-76e96df6f0b1?",
    "scraped_at": "2025-03-30T01:59:23.482414"
  },
  {
    "url": "https://medium.datadriveninvestor.com/250-python-and-data-science-tips-covering-pandas-numpy-ml-basics-sklearn-jupyter-and-more-e33074b92d58",
    "title": "250+ Python and Data Science Tips ‚Äî Covering Pandas, NumPy, ML Basics, Sklearn, Jupyter, and More.",
    "author": "",
    "published_date": null,
    "reading_time": "6 min read",
    "tags": [
      "Data Science",
      "Machine Learning",
      "Python",
      "Programming",
      "Artificial Intelligence"
    ],
    "content": [
      {
        "type": "h1",
        "content": "250+ Python and Data Science Tips ‚Äî Covering Pandas, NumPy, ML Basics, Sklearn, Jupyter, and More."
      },
      {
        "type": "h2",
        "content": "A self-curated collection of Python and Data Science tips to level up your data game."
      },
      {
        "type": "p",
        "content": "Avi Chawla"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "DataDrivenInvestor"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "3"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "Being a data scientist demands expertise in plenty of areas. You need to be good at using appropriate tools, like Pandas, NumPy, Sklearn, etc."
      },
      {
        "type": "p",
        "content": "These are indispensable to the development life cycle of many data-driven projects, making them essential skills to begin/maintain a career in data science."
      },
      {
        "type": "p",
        "content": "What‚Äôs more, SQL is pivotal to almost all data science roles today."
      },
      {
        "type": "p",
        "content": "Additionally, data storytelling is equally essential to effectively convey your findings and insights to a broader audience."
      },
      {
        "type": "p",
        "content": "One must also possess a firm understanding of statistics to perform data analysis and make data-driven decisions."
      },
      {
        "type": "p",
        "content": "And of course, you can never forget ML fundamentals."
      },
      {
        "type": "p",
        "content": "All in all, it‚Äôs a lot, isn‚Äôt it?"
      },
      {
        "type": "p",
        "content": "But it‚Äôs fun. A lot of fun, in fact."
      },
      {
        "type": "p",
        "content": "To simplify this data science journey and make it appear less intimidating and more accessible, I have been sharing daily tips for over 250 days."
      },
      {
        "type": "p",
        "content": "And after completing 250 days, I made a full PDF archive, which lists all the posts I have written."
      },
      {
        "type": "p",
        "content": "As mentioned above, it has 250+ tips and comprises over 350 Pages. In this blog, I am sharing five of my most loved tips so far."
      },
      {
        "type": "p",
        "content": "üëâ You can find the whole PDF archive here."
      },
      {
        "type": "p",
        "content": "Let‚Äôs begin üöÄ!"
      },
      {
        "type": "h1",
        "content": "#1 A Simple Trick That Will Make Heatmaps More Elegant"
      },
      {
        "type": "p",
        "content": "Heatmaps often make data analysis much easier. Yet, they can be further enriched with a simple modification."
      },
      {
        "type": "p",
        "content": "A traditional heatmap represents the values using a color scale. Yet, mapping the cell color to numbers is still challenging."
      },
      {
        "type": "p",
        "content": "Embedding a size component to them, as shown above, can be extremely helpful in such cases. In essence, the bigger the size, the higher the absolute value."
      },
      {
        "type": "p",
        "content": "This is especially useful to make heatmaps cleaner, as many values nearer to zero will immediately shrink."
      },
      {
        "type": "p",
        "content": "In fact, you can represent the size with any other shape. Below, I created the same heatmap using a circle instead:"
      },
      {
        "type": "h1",
        "content": "#2 Why Are We Typically Advised To Never Iterate Over A DataFrame?"
      },
      {
        "type": "p",
        "content": "From time to time, we are advised to avoid iterating on a Pandas DataFrame. But what is the exact reason behind this? Let me explain."
      },
      {
        "type": "p",
        "content": "A DataFrame is a column-major data structure. Thus, consecutive elements in a column are stored next to each other in memory."
      },
      {
        "type": "p",
        "content": "As processors are efficient with contiguous blocks of memory, retrieving a column is much faster than a row."
      },
      {
        "type": "p",
        "content": "But while iterating, as each row is retrieved by accessing non-contiguous blocks of memory, the run-time increases drastically."
      },
      {
        "type": "p",
        "content": "In the image above, retrieving over 32M elements of a column was still over 20x faster than fetching just nine elements stored in a row."
      },
      {
        "type": "h1",
        "content": "#3 An Underrated Technique To Create Better Data Plots"
      },
      {
        "type": "p",
        "content": "While creating visualizations, there are often certain parts that are particularly important. Yet, they may not be immediately obvious to the viewer."
      },
      {
        "type": "p",
        "content": "A good data storyteller will always ensure that the plot guides the viewer‚Äôs attention to these key areas."
      },
      {
        "type": "p",
        "content": "One great way is to zoom in on specific regions of interest in a plot. This ensures that our plot indeed communicates what we intend it to depict."
      },
      {
        "type": "p",
        "content": "In matplotlib, you can do so using ùê¢ùêßùêùùê¢ùêúùêöùê≠ùêû_ùê¢ùêßùê¨ùêûùê≠_ùê≥ùê®ùê®ùê¶(). It adds an indicator box, that can be zoomed-in for better communication."
      },
      {
        "type": "h1",
        "content": "#4 Why Correlation (and Other Statistics) Can Be Misleading."
      },
      {
        "type": "p",
        "content": "Correlation is often used to determine the association between two continuous variables. But it has a major flaw that often gets unnoticed."
      },
      {
        "type": "p",
        "content": "Folks often draw conclusions using a correlation matrix without even looking at the data. However, outliers or other artifacts could heavily drive the obtained statistics."
      },
      {
        "type": "p",
        "content": "This is demonstrated in the plots above. The addition of just two outliers changed the correlation and the regression line drastically."
      },
      {
        "type": "p",
        "content": "Thus, looking at the data and understanding its underlying characteristics can save from drawing wrong conclusions. Statistics are important, but they can be highly misleading at times."
      },
      {
        "type": "h1",
        "content": "#5 A Nasty Hidden Feature of Python That Many Programmers Aren‚Äôt Aware Of"
      },
      {
        "type": "p",
        "content": "Mutability in Python is possibly one of the most misunderstood and overlooked concepts. The above image demonstrates an example that many Python programmers (especially new ones) struggle to understand."
      },
      {
        "type": "p",
        "content": "Can you figure it out? If not, let‚Äôs understand it."
      },
      {
        "type": "p",
        "content": "The default parameters of a function are evaluated right at the time the function is defined. In other words, they are not evaluated each time the function is called (like in C++)."
      },
      {
        "type": "p",
        "content": "Thus, as soon as a function is defined, the function object stores the default parameters in its __defaults__ attribute. We can verify this below:"
      },
      {
        "type": "p",
        "content": "Thus, if you specify a mutable default parameter in a function and mutate it, you unknowingly and unintentionally modify the parameter for all future calls to that function."
      },
      {
        "type": "p",
        "content": "This is shown in the demonstration below. Instead of creating a new list at each function call, Python appends the element to the same copy."
      },
      {
        "type": "h2",
        "content": "So what can we do to avoid this?"
      },
      {
        "type": "p",
        "content": "Instead of specifying a mutable default parameter in a function‚Äôs definition, replace them with None. If the function does not receive a corresponding value during the function call, create the mutable object inside the function."
      },
      {
        "type": "p",
        "content": "This is demonstrated below:"
      },
      {
        "type": "p",
        "content": "As shown above, we create a new list if the function didn‚Äôt receive any value when it was called. This lets you avoid the unexpected behavior of mutating the same object."
      },
      {
        "type": "h1",
        "content": "Conclusion"
      },
      {
        "type": "p",
        "content": "With this, we come to the end of this blog. I really hope you learned something new."
      },
      {
        "type": "p",
        "content": "While this article only covered five of the tips I have shared so far from over 250 posts, you can read all of them in my single archive PDF."
      },
      {
        "type": "p",
        "content": "I am sure you will love it."
      },
      {
        "type": "p",
        "content": "üëâ You can find this PDF document here. Data Science Archive."
      },
      {
        "type": "p",
        "content": "Thanks for reading!"
      },
      {
        "type": "p",
        "content": "Subscribe to DDIntel Here."
      },
      {
        "type": "p",
        "content": "Visit our website here: https://www.datadriveninvestor.com"
      },
      {
        "type": "p",
        "content": "Join our network here: https://datadriveninvestor.com/collaborate"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:27.070962"
  },
  {
    "url": "https://medium.com/learning-python-programming-language",
    "error": "'NoneType' object is not callable",
    "scraped_at": "2025-03-30T01:59:29.827254"
  },
  {
    "url": "https://dextrop.medium.com/a-comprehensive-guide-to-python-introduction-and-key-topics-95a412025f94",
    "title": "A Comprehensive Guide to Python: Introduction and Key Topics",
    "author": "Working with Python VariablesIn Python, variables are used to store data values that can be manipulated or used in operations within a program‚Ä¶medium.com",
    "published_date": null,
    "reading_time": "7 min read",
    "tags": [
      "Python",
      "Python Programming",
      "Python3",
      "Python 3 Tutorial",
      "Jennieautomations"
    ],
    "content": [
      {
        "type": "h1",
        "content": "A Comprehensive Guide to Python: Introduction and Key Topics"
      },
      {
        "type": "p",
        "content": "Saurabh Pandey"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "Python is a versatile and popular programming language known for its simplicity and readability. Whether you are a beginner or an experienced developer, Python offers a wide range of capabilities that make it suitable for various applications. In this article, we will provide a basic introduction to Python, showcase some print statements to demonstrate its simplicity, and briefly explore each of the Python topics covered in the articles written by Jennie, a Python enthusiast and writer."
      },
      {
        "type": "p",
        "content": "Python Basics: Python is an interpreted, high-level programming language that emphasizes code readability and ease of use. It has a clean and straightforward syntax, making it accessible for beginners while remaining powerful enough for complex projects. Let‚Äôs start with a simple ‚ÄúHello, World!‚Äù program in Python:"
      },
      {
        "type": "pre",
        "content": "print(\"Hello, World!\")"
      },
      {
        "type": "p",
        "content": "This single line of code demonstrates the essence of Python‚Äôs simplicity and readability. By executing this code, the phrase ‚ÄúHello, World!‚Äù will be displayed in the output console."
      },
      {
        "type": "p",
        "content": "Now, let‚Äôs delve into the various Python topics covered in the articles."
      },
      {
        "type": "h1",
        "content": "1. Working with Python Variables"
      },
      {
        "type": "p",
        "content": "Variables are fundamental elements in Python for storing and manipulating data. This article delves into the world of Python variables, explaining variable types, naming conventions, and variable scope. It provides insights into working with different data types and managing variables effectively."
      },
      {
        "type": "h2",
        "content": "Working with Python Variables"
      },
      {
        "type": "h3",
        "content": "In Python, variables are used to store data values that can be manipulated or used in operations within a program‚Ä¶"
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "p",
        "content": "These articles, starting from the basics of data analysis and progressing to more advanced topics like decorators and generators, cover a wide range of essential Python concepts. Whether you‚Äôre a beginner or an experienced programmer, these articles offer valuable knowledge and practical examples to expand your understanding of Python."
      },
      {
        "type": "h1",
        "content": "2. Understanding If-Else, While, and For Loops"
      },
      {
        "type": "p",
        "content": "Control flow statements allow you to control the execution flow in Python programs. This article provides an in-depth understanding of if-else statements, while loops, and for loops. It demonstrates how to make decisions based on conditions and how to perform iterative tasks."
      },
      {
        "type": "h2",
        "content": "Python Control Flow Statements: Understanding If/Else, While, and For Loops"
      },
      {
        "type": "h3",
        "content": "Control flow statements are an essential part of any programming language, including Python. These statements allow you‚Ä¶"
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "h1",
        "content": "3. Functions and Modules in Python"
      },
      {
        "type": "p",
        "content": "Functions and modules are essential for code organization and reusability. This article explores the concepts of functions and modules in Python, demonstrating how to define and use functions and how to create and import modules."
      },
      {
        "type": "h2",
        "content": "Functions and Modules in Python: Unlocking the Power of Reusability"
      },
      {
        "type": "h3",
        "content": "Introduction"
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "h1",
        "content": "4. Embracing Object-Oriented Programming in Python"
      },
      {
        "type": "p",
        "content": "Object-oriented programming (OOP) is a powerful paradigm in Python. This article serves as an introduction to OOP concepts in Python, including classes, objects, inheritance, and encapsulation. It demonstrates how to create and utilize classes and objects to write modular and reusable code."
      },
      {
        "type": "h2",
        "content": "Embracing Object-Oriented Programming in Python: An Introduction"
      },
      {
        "type": "h3",
        "content": "A class is a blueprint for creating objects (a particular data structure). It defines a set of attributes and methods‚Ä¶"
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "h1",
        "content": "5. Making HTTP Requests in Python: A Comprehensive Guide"
      },
      {
        "type": "p",
        "content": "This article offers a comprehensive guide to making HTTP requests using Python. It explains how to interact with web APIs and covers popular libraries such as Requests and urllib for sending requests and handling responses."
      },
      {
        "type": "h2",
        "content": "Making HTTP Requests in Python: A Comprehensive Guide"
      },
      {
        "type": "h3",
        "content": "HTTP requests are an essential part of web development and APIs, as they allow communication between clients and‚Ä¶"
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "h1",
        "content": "6. Mastering File I/O in Python: Read, Write, and Manipulate Files Effortlessly"
      },
      {
        "type": "p",
        "content": "File input/output (I/O) operations are crucial for working with files in Python. This article provides a comprehensive guide to file I/O in Python, covering techniques for reading, writing, and manipulating files. It explores different modes of file access, such as reading, writing, and appending, and demonstrates practical examples of file manipulation."
      },
      {
        "type": "h2",
        "content": "Mastering File I/O in Python: Read, Write, and Manipulate Files Effortlessly"
      },
      {
        "type": "h3",
        "content": "File Input/Output (I/O) operations are an essential aspect of any programming language, including Python. They allow‚Ä¶"
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "h1",
        "content": "7. Unleashing the Power of Decorators and Generators in Python"
      },
      {
        "type": "p",
        "content": "Decorators and generators are advanced features in Python that enhance code functionality and efficiency. This article explores the concept of decorators, which allow you to modify the behavior of functions or classes, and generators, which enable the creation of iterator functions. It provides practical examples to showcase the power and versatility of decorators and generators."
      },
      {
        "type": "h2",
        "content": "Unleashing the Power of Decorators and Generators in Python"
      },
      {
        "type": "h3",
        "content": "Decorators and generators are advanced Python features that empower developers to write efficient, modular, and cleaner‚Ä¶"
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "h1",
        "content": "8. Harnessing the Power of Regular Expressions in Python"
      },
      {
        "type": "p",
        "content": "Regular expressions are powerful tools for pattern matching and text manipulation. This article dives into regular expressions in Python, explaining the syntax and usage of regular expression patterns. It showcases how to apply regular expressions to search, match, and manipulate text data effectively."
      },
      {
        "type": "h2",
        "content": "Harnessing the Power of Regular Expressions in Python"
      },
      {
        "type": "h3",
        "content": "Regular expressions, often abbreviated as regex, are a powerful tool for text processing and pattern matching in‚Ä¶"
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "h1",
        "content": "9. Web Scraping: The Process of Extracting Data from Websites"
      },
      {
        "type": "p",
        "content": "This article introduces the concept of web scraping and explains how to extract data from websites using Python. It covers the use of popular libraries such as BeautifulSoup and Requests for web scraping tasks."
      },
      {
        "type": "h2",
        "content": "Scrapping website with python: Python Web Scrapping"
      },
      {
        "type": "h3",
        "content": "Web scraping, or data scraping, is the process of extracting data from websites. It can be a useful technique for‚Ä¶"
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "h1",
        "content": "10. Socket Programming in Python: A Comprehensive Guide"
      },
      {
        "type": "p",
        "content": "Socket programming allows communication between computers over a network. This comprehensive guide covers the basics of socket programming in Python, including both the client and server sides. It provides insights into building network applications using Python‚Äôs socket module."
      },
      {
        "type": "h2",
        "content": "Socket Programming in Python: A Comprehensive Guide"
      },
      {
        "type": "h3",
        "content": "Socket programming is a method of communication between two computers using a network protocol, typically TCP/IP. In‚Ä¶"
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "h1",
        "content": "11. Database Programming with Python: SQLite, MySQL, and PostgreSQL"
      },
      {
        "type": "p",
        "content": "Python provides convenient ways to work with databases. This article explores database programming using various database systems, including SQLite, MySQL, and PostgreSQL. It covers connecting to databases, executing queries, and managing data using Python."
      },
      {
        "type": "h2",
        "content": "Database Programming with Python: SQLite, MySQL, and PostgreSQL"
      },
      {
        "type": "h3",
        "content": "Python offers robust support for working with various databases, making it easy to store, retrieve, and manipulate‚Ä¶"
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "h1",
        "content": "12. Data Analysis with Python: Introduction to NumPy, SciPy, and matplotlib"
      },
      {
        "type": "p",
        "content": "This introductory article explores essential libraries for data analysis in Python, namely NumPy, SciPy, and Matplotlib. It covers the basics of these libraries and demonstrates their usage through practical examples."
      },
      {
        "type": "h2",
        "content": "Database Programming with Python: SQLite, MySQL, and PostgreSQL"
      },
      {
        "type": "h3",
        "content": "Python offers robust support for working with various databases, making it easy to store, retrieve, and manipulate‚Ä¶"
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "h1",
        "content": "13. Debugging and Testing in Python: A Comprehensive Guide"
      },
      {
        "type": "p",
        "content": "Effective debugging and testing are crucial for writing reliable code. This comprehensive guide explores techniques for debugging and testing Python code. It covers strategies for identifying and fixing bugs, writing test cases using the unittest module, and employing debugging tools."
      },
      {
        "type": "h2",
        "content": "Debugging and Testing in Python: A Comprehensive Guide"
      },
      {
        "type": "h3",
        "content": "Debugging and testing are essential aspects of software development. Ensuring that your code is error-free and performs‚Ä¶"
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "h1",
        "content": "14. Harnessing the Power of Regular Expressions in Python"
      },
      {
        "type": "p",
        "content": "Regular expressions are powerful tools for pattern matching and text manipulation. This article dives into regular expressions in Python, explaining the syntax and usage of regular expression patterns. It showcases how to apply regular expressions to search, match, and manipulate text data effectively."
      },
      {
        "type": "h2",
        "content": "Harnessing the Power of Regular Expressions in Python"
      },
      {
        "type": "h3",
        "content": "Regular expressions, often abbreviated as regex, are a powerful tool for text processing and pattern matching in‚Ä¶"
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "h1",
        "content": "15. Best Practices"
      },
      {
        "type": "p",
        "content": "Last but not the least"
      },
      {
        "type": "h2",
        "content": "15 best practices every Python developer must know"
      },
      {
        "type": "h3",
        "content": "Indentation should be four spaces and not tabs"
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "p",
        "content": "Here are five additional resources to explore and learn more about Python:"
      },
      {
        "type": "p",
        "content": "These resources offer a wealth of information and learning opportunities for Python enthusiasts. Whether you prefer tutorials, documentation, newsletters, books, or a combination of these, they will help you deepen your Python knowledge and expand your skills in different domains."
      },
      {
        "type": "h1",
        "content": "About the Author"
      },
      {
        "type": "p",
        "content": "Author Name: Saurabh Pandey"
      },
      {
        "type": "p",
        "content": "Saurabh Pandey is a passionate Software Engineer from India. With years of experience in the industry, Saurabh has honed his skills in various programming languages and technologies, allowing him to effectively lead and contribute to complex projects."
      },
      {
        "type": "p",
        "content": "To connect with Saurabh and learn more about his work, you can visit his LinkedIn profile at https://www.linkedin.com/in/dextrop/."
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:31.972769"
  },
  {
    "url": "https://angietechcafe.medium.com/python-101-a-beginners-guide-to-learning-python-ffd620060fa4",
    "title": "Python 101 for beginners",
    "author": "Press",
    "published_date": null,
    "reading_time": "3 min read",
    "tags": [
      "Python",
      "Programming",
      "Coding",
      "Coding For Beginners"
    ],
    "content": [
      {
        "type": "h1",
        "content": "Python 101 for beginners"
      },
      {
        "type": "p",
        "content": "Angie"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "Python is a widely used programming language that has gained popularity due to its versatility, simplicity, and active community. It is an ideal choice for beginners and seasoned programmers alike. In this post, I will guide you through a beginner‚Äôs journey to learning Python by breaking it down into simple steps."
      },
      {
        "type": "p",
        "content": "Why Learn Python?"
      },
      {
        "type": "p",
        "content": "Python is a powerful language with numerous features, making it a popular choice for developers worldwide. Below are some reasons you should consider learning Python:"
      },
      {
        "type": "p",
        "content": "‚Äî Beginner-friendly: Python‚Äôs syntax is easy to read and write, making it an excellent choice for beginners."
      },
      {
        "type": "p",
        "content": "‚Äî Versatility: Python is used for several applications, including web development, machine learning, data analysis, and more."
      },
      {
        "type": "p",
        "content": "‚Äî Large community: Python has a large and active community of developers who offer support, documentation, and tutorials."
      },
      {
        "type": "p",
        "content": "‚Äî Libraries: Python has a vast collection of libraries and frameworks that allow you to leverage existing code rather than writing everything from scratch."
      },
      {
        "type": "p",
        "content": "Step 1: Install Python and Set Up Your Environment"
      },
      {
        "type": "p",
        "content": "Before you start learning Python, you need to install Python on your computer and set up your development environment. You can install the latest version of Python 3 from the official website. Setting up your development environment involves installing an Integrated Development Environment (IDE) or a text editor, such as VS Code, PyCharm, or Sublime Text."
      },
      {
        "type": "p",
        "content": "I recommend starting with VS Code, which is free and beginner-friendly. Install VS Code, then search for and install the Python extension to get all the bells and whistles for Python development."
      },
      {
        "type": "p",
        "content": "Step 2: Learn Python Syntax and Basic Concepts"
      },
      {
        "type": "p",
        "content": "With your environment set up, it‚Äôs time to start learning Python. Begin by focusing on the basics of Python syntax, data types, variables, conditional logic, loops, functions, classes, and other fundamental concepts."
      },
      {
        "type": "p",
        "content": "Interactive tutorials and coding exercises are an excellent way to learn Python basics. Some helpful resources for beginners include:"
      },
      {
        "type": "p",
        "content": "‚Äî Python official tutorial"
      },
      {
        "type": "p",
        "content": "‚Äî FreeCodeCamp Python course"
      },
      {
        "type": "p",
        "content": "‚Äî Automate the Boring Stuff with Python book"
      },
      {
        "type": "p",
        "content": "Please take your time to make sure you understand each concept before moving on. Writing small scripts is an excellent way to practice and cement your knowledge."
      },
      {
        "type": "p",
        "content": "Step 3: Work on Some Python Projects"
      },
      {
        "type": "p",
        "content": "Once you grasp Python basics well, you can start working on Python projects to apply your skills practically. Start with simple projects like a number guessing game, mad libs generator, or a Python script to perform mundane tasks like batch-renaming files. As you gain more experience, you can move on to more complex projects like:"
      },
      {
        "type": "p",
        "content": "‚Äî Web scraping scripts to extract data from websites"
      },
      {
        "type": "p",
        "content": "‚Äî Python scripts to automate everyday tasks"
      },
      {
        "type": "p",
        "content": "‚Äî Data analysis projects using libraries like Pandas"
      },
      {
        "type": "p",
        "content": "‚Äî Simple web apps using Flask"
      },
      {
        "type": "p",
        "content": "‚Äî Basic games or GUI application"
      },
      {
        "type": "p",
        "content": "Completing Python projects will help you apply what you‚Äôve learned and reinforce your knowledge."
      },
      {
        "type": "p",
        "content": "Step 4: Continue Your Python Journey"
      },
      {
        "type": "p",
        "content": "Learning Python is an ongoing process that requires consistent practice and effort. After mastering Python basics, you can dive deeper into advanced topics like:"
      },
      {
        "type": "p",
        "content": "‚Äî Object-oriented programming in Python"
      },
      {
        "type": "p",
        "content": "‚Äî Working with databases in Python"
      },
      {
        "type": "p",
        "content": "‚Äî Testing and debugging in Python"
      },
      {
        "type": "p",
        "content": "‚Äî Contributing to open source Python projects"
      },
      {
        "type": "p",
        "content": "Participating in online Python communities, taking advanced Python courses and projects, and reading programming books will help you improve your skills as a Python developer. The most important thing is to keep practicing. Python is a powerful language with endless possibilities. Enjoy exploring all it has to offer!"
      },
      {
        "type": "h1",
        "content": "Read More Tech Content Here ‚¨áÔ∏è"
      },
      {
        "type": "p",
        "content": "Angie"
      },
      {
        "type": "h2",
        "content": "Angie's Tech Content Track"
      },
      {
        "type": "h1",
        "content": "Buy Me a Book üìñ"
      },
      {
        "type": "p",
        "content": "Angie"
      },
      {
        "type": "h2",
        "content": "Angie's  Morning Vibes"
      },
      {
        "type": "h1",
        "content": "Thanks for reading!"
      },
      {
        "type": "p",
        "content": "One moment. You should get my articles in your inbox. Subscribe here."
      },
      {
        "type": "p",
        "content": "üë©‚Äçüíª Follow me on GitHub | Substack for lifestyle & cyber education üë©‚Äçüíª"
      },
      {
        "type": "p",
        "content": "I also hope that you have a wonderful day. ‚ú®"
      },
      {
        "type": "p",
        "content": "Follow for more:"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:34.107459"
  },
  {
    "url": "https://igmguru.medium.com/what-is-python-and-its-fundamentals-to-become-python-developer-7f6b9b24c1de",
    "title": "What Is Python? A Complete Guide For Beginners",
    "author": "Press",
    "published_date": null,
    "reading_time": "6 min read",
    "tags": [
      "Python",
      "Python Programming",
      "Python Training Course",
      "Python Course Online",
      "Python Certification"
    ],
    "content": [
      {
        "type": "h1",
        "content": "What Is Python? A Complete Guide For Beginners"
      },
      {
        "type": "p",
        "content": "igmGuru"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "h1",
        "content": "1. Introduction to Python"
      },
      {
        "type": "p",
        "content": "Python is a high-level, interpreted programming language that is widely used for web development, data analysis, artificial intelligence, and scientific computing. It is a versatile language that is well-suited for a wide range of tasks and is known for its simplicity and readability."
      },
      {
        "type": "p",
        "content": "One of the key features of Python is its vast ecosystem of libraries and frameworks, which makes it easy to perform complex tasks with minimal code. For example, the popular libraries NumPy and Pandas make it easy to work with large datasets, while the libraries scikit-learn and TensorFlow make it easy to build machine-learning models."
      },
      {
        "type": "p",
        "content": "Python also has a large and active community, which means there is a wealth of tutorials, documentation, and support available for those who are learning the language. Python training is also important to learn all its fundamentals with ease."
      },
      {
        "type": "p",
        "content": "Python was first released in 1991 by Guido van Rossum, and it has since grown to become one of the most popular programming languages in the world. It is widely used in industry, academia, and government for a wide range of tasks, including web development, data analysis, and machine learning."
      },
      {
        "type": "p",
        "content": "Python is an open-source language, which means that it is free to use and distribute, and the source code is available for anyone to inspect and modify."
      },
      {
        "type": "p",
        "content": "Overall, Python is a great language to learn for anyone interested in programming, and it can be used for various purposes such as web development, data science, artificial intelligence, and much more."
      },
      {
        "type": "p",
        "content": "Here are some facts about Python-"
      },
      {
        "type": "p",
        "content": "¬∑ History and background of Python: This section would cover the origins of the Python programming language, its creator Guido van Rossum, and the reasons why it was created. It would also include information about its popularity and use cases."
      },
      {
        "type": "p",
        "content": "¬∑ Setting up a development environment: This section would cover how to install Python and any necessary dependencies on different operating systems, as well as how to set up a development environment using an IDE (Integrated Development Environment) or text editor."
      },
      {
        "type": "p",
        "content": "¬∑ Basic syntax and data types: This section would cover the basic syntax of Python, including indentation and naming conventions, as well as the various data types supported by Python, such as strings, integers, floats, and booleans."
      },
      {
        "type": "p",
        "content": "¬∑ Basic commands and operations: This section would cover basic commands and operations that are used in python like print, input, range, while, if-else, etc."
      },
      {
        "type": "h1",
        "content": "2. Python Fundamentals"
      },
      {
        "type": "p",
        "content": "¬∑ Variables and Operators: This section would cover the basics of variables, how to declare and assign values, and the different types of operators available in Python, such as arithmetic, comparison, and logical operators."
      },
      {
        "type": "p",
        "content": "¬∑ Control Flow and Loops: This section would cover the different control flow statements available in Python, such as if/else statements and for/while loops, and how to use them to control the flow of a program."
      },
      {
        "type": "p",
        "content": "¬∑ Functions and Modules: This section would cover how to create and use functions in Python, including the use of parameters and return values, and how to use modules, including the import statement and built-in modules."
      },
      {
        "type": "p",
        "content": "¬∑ Object-Oriented Programming: This section would cover the basics of object-oriented programming in Python, including classes, objects, inheritance, and polymorphism."
      },
      {
        "type": "p",
        "content": "¬∑ Exception Handling: This section would cover how to handle and raise exceptions in python."
      },
      {
        "type": "p",
        "content": "¬∑ List, Tuples, and Dictionaries: This section would cover the data structures available in python like lists, tuples, and dictionaries, and how to use them to store and manipulate data in an efficient way."
      },
      {
        "type": "h1",
        "content": "3. Advanced Python Concepts"
      },
      {
        "type": "p",
        "content": "¬∑ Error and Exception Handling: This section would cover how to handle and raise exceptions in python and the built-in exception types. It would also cover how to use try-except and try-finally blocks for exception handling and how to create custom exceptions."
      },
      {
        "type": "p",
        "content": "¬∑ File Input/Output: This section would cover how to read and write files in python, including opening and closing files, reading and writing data, and working with file paths."
      },
      {
        "type": "p",
        "content": "¬∑ Regular Expressions: This section would cover how to use regular expressions in python to match and manipulate strings, including the use of special characters and meta characters and common use cases like pattern matching and data validation."
      },
      {
        "type": "p",
        "content": "¬∑ Debugging and testing: This section would cover how to debug and test python code, including using the built-in debugging tools such as pdb, and using testing frameworks such as unit tests."
      },
      {
        "type": "p",
        "content": "¬∑ Lambda function, map, filter, and reduce: This section would cover the functional programming concepts of python like lambda function, map, filter, reduce, and how to use them to write more efficient and readable code."
      },
      {
        "type": "p",
        "content": "¬∑ Decorators: This section would cover how to use decorators in python to add functionality to functions and classes."
      },
      {
        "type": "p",
        "content": "¬∑ Generators and Iterators: This section would cover the concepts of generator and iterator in python and how to use them to create efficient and memory-friendly code."
      },
      {
        "type": "h1",
        "content": "4. Python Libraries and Frameworks"
      },
      {
        "type": "p",
        "content": "¬∑ NumPy and Pandas for data analysis: This section would cover the use of the NumPy and Pandas libraries for working with numerical and tabular data in python, including array manipulation, statistical operations, and data cleaning and preparation."
      },
      {
        "type": "p",
        "content": "¬∑ Matplotlib and Seaborn for data visualization: This section would cover the use of the Matplotlib and Seaborn libraries for creating various types of plots and visualizations, including line plots, scatter plots, bar charts, and heat maps."
      },
      {
        "type": "p",
        "content": "¬∑ Scikit-learn for machine learning: This section would cover the use of the scikit-learn library for implementing machine learning algorithms, including supervised and unsupervised learning, and model evaluation."
      },
      {
        "type": "p",
        "content": "¬∑ Django and Flask for web development: This section would cover the use of the Django and Flask frameworks for creating web applications in python, including handling requests and responses, routing, and database integration."
      },
      {
        "type": "p",
        "content": "¬∑ Web scraping with Beautiful Soup and Scrappy: This section would cover the use of the Beautiful Soup and Scrappy libraries for scraping data from websites, including parsing HTML and XML, navigating the Document Object Model (DOM), and handling AJAX requests."
      },
      {
        "type": "p",
        "content": "¬∑ Requests and JSON: This section would cover the use of the requests library for sending HTTP requests and handling the response, it also covers working with JSON data."
      },
      {
        "type": "p",
        "content": "Please note that this list is not exhaustive, there are many other libraries and frameworks available in python that can be used for different tasks."
      },
      {
        "type": "h1",
        "content": "5. Project and Case studies"
      },
      {
        "type": "p",
        "content": "¬∑ Developing a Python application: This section would cover the process of developing a complete Python application, including designing the application, writing the code, testing, and deploying the application. The application could be a simple command-line tool, a desktop application, or a web application."
      },
      {
        "type": "p",
        "content": "¬∑ Analyzing real-world data: This section would cover the process of loading, cleaning, and analyzing real-world data using Python libraries such as NumPy, Pandas, and Matplotlib. It could include a case study of analyzing data from a specific domain such as finance, healthcare, or social media."
      },
      {
        "type": "p",
        "content": "¬∑ Creating a web service: This section would cover the process of creating a web service using a Python web framework such as Flask or Django. It would include topics such as routing, handling requests, and database integration."
      },
      {
        "type": "p",
        "content": "¬∑ Building a machine learning model: This section would cover the process of building a machine learning model using Python libraries such as scikit-learn, Tensor flow, or Pytorch. It would include topics such as feature engineering, model selection, and evaluation."
      },
      {
        "type": "p",
        "content": "¬∑ Network programming: This section would cover the basics of network programming in python, including socket programming, creating a client-server application, and working with protocols such as HTTP, FTP, etc."
      },
      {
        "type": "p",
        "content": "This section would be an opportunity for students to apply the concepts they have learned throughout the course to real-world projects. It would also provide an opportunity for students to work on their own projects and showcase their work to the class."
      },
      {
        "type": "h1",
        "content": "Conclusion"
      },
      {
        "type": "p",
        "content": "Review of key concepts: This section would review the key concepts covered throughout the Python course, highlighting the most important takeaways, and providing a summary of the material."
      },
      {
        "type": "p",
        "content": "Additional resources for further learning would provide a list of resources such as books, tutorials, and websites for students to continue their learning after the course."
      },
      {
        "type": "p",
        "content": "Tips for staying up-to-date with Python developments would provide tips for staying current with the latest developments in Python, including new libraries, frameworks, and best practices. It would also provide guidance for contributing to the open-source Python community."
      },
      {
        "type": "p",
        "content": "There are a lot of career opportunities once you become a Python developer, such as data analyst, data scientist, software developer, web developer, and many more."
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:36.239105"
  },
  {
    "url": "https://medium.com/@oasiegbulam/object-oriented-programming-oop-in-python-an-in-depth-guide-for-beginners-50cf5d086b60",
    "title": "Object-Oriented Programming (OOP) in Python: A Guide for Beginners",
    "author": "Mastodon",
    "published_date": null,
    "reading_time": "4 min read",
    "tags": [
      "Oop",
      "Oop Concepts",
      "Python",
      "Python Programming",
      "Web Development"
    ],
    "content": [
      {
        "type": "h1",
        "content": "Object-Oriented Programming (OOP) in Python: A Guide for Beginners"
      },
      {
        "type": "p",
        "content": "Obinna ‚ÄúAnderson‚Äù Asiegbulam"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "Object-Oriented Programming, or OOP for short, is more than just a programming style; it‚Äôs a way of thinking about and solving complex software design issues. OOP focuses on the objects that developers want to manipulate rather than the logic required to manipulate them. This approach to programming is well-suited for programs that are large, complex, and actively updated or maintained."
      },
      {
        "type": "h1",
        "content": "1. Understanding the Core Concepts of OOP"
      },
      {
        "type": "p",
        "content": "OOP is built around several key concepts that are universal across programming languages that support OOP, such as Python, Java, C++, and more. OOP revolves around four main concepts: Encapsulation, Abstraction, Inheritance, and Polymorphism."
      },
      {
        "type": "h1",
        "content": "Encapsulation"
      },
      {
        "type": "p",
        "content": "Encapsulation is about bundling the data (attributes) and the methods (functions) that manipulate the data into a single unit called a class. It also restricts direct access to some of an object‚Äôs components, which is a means of preventing unintended interference and misuse of the data. For instance, an object that represents a bank account should not allow the account balance to be changed directly from outside the object‚Äôs methods."
      },
      {
        "type": "h1",
        "content": "Abstraction"
      },
      {
        "type": "p",
        "content": "Abstraction involves creating simple, more usable representations of complex entities. Consider a car. You don‚Äôt need to understand the intricacies of the internal combustion engine to drive a car. Similarly, objects in OOP expose interfaces (methods) that can be used without requiring the user to understand what‚Äôs going on under the hood."
      },
      {
        "type": "h1",
        "content": "Inheritance"
      },
      {
        "type": "p",
        "content": "Inheritance allows new objects to take on the properties of existing objects. This is a powerful way to establish a type hierarchy and encourage code reusability. For instance, you might have a base class Vehicle and subclasses such as Truck and Motorcycle that inherit from Vehicle but also introduce specific attributes and methods."
      },
      {
        "type": "h1",
        "content": "Polymorphism"
      },
      {
        "type": "p",
        "content": "Polymorphism is the ability for different classes to be treated as instances of the same class through inheritance. It allows the same interface to be used for different underlying forms (data types). For example, if Truck and Motorcycle are both types of Vehicle, they may both inherit a method called drive(), but each implements it differently."
      },
      {
        "type": "h1",
        "content": "2. Procedural vs. Object-Oriented Programming"
      },
      {
        "type": "h1",
        "content": "Procedural Programming"
      },
      {
        "type": "p",
        "content": "Procedural programming is a programming paradigm based on the concept of procedure calls, where procedures (also known as routines, subroutines, or functions) organize code into reusable blocks. Procedural code tends to be more straightforward and less abstract than OOP code, but it can become unwieldy as programs grow larger and more complex."
      },
      {
        "type": "h1",
        "content": "Object-Oriented Programming"
      },
      {
        "type": "p",
        "content": "OOP is often more suitable for larger, more complex, and actively updated/maintained software. It can be more difficult to learn than procedural programming due to its higher level of abstraction. OOP is about entities called objects and the interactions between these objects. Objects represent a combination of data and the operations that can be performed on that data."
      },
      {
        "type": "p",
        "content": "Real-World Problem & Solution Example:"
      },
      {
        "type": "p",
        "content": "Problem: You need to develop a software system that manages a fleet of delivery vehicles for a logistics company."
      },
      {
        "type": "p",
        "content": "Solution: Using OOP, you can create classes for each element of the system, such as Vehicle, Route, Driver, and Package. Each class encapsulates the data it needs and the operations it can perform. Vehicle might have methods like start_engine() and properties like fuel_level. Driver might have methods like drive() and properties like license_number. The Route class might have a method called calculate_optimal_route()."
      },
      {
        "type": "h1",
        "content": "3. Classes and Objects in Python"
      },
      {
        "type": "p",
        "content": "In Python, classes are the templates for creating objects, and an object is an instance of a class."
      },
      {
        "type": "h1",
        "content": "Defining a Class in Python"
      },
      {
        "type": "p",
        "content": "A class is defined using the class keyword. Classes can have methods (defined with functions) and properties (defined with variables)."
      },
      {
        "type": "pre",
        "content": "class Dog:    species = \"Canis familiaris\"  # Class attribute    def __init__(self, name, age):  # Constructor method        self.name = name  # Instance attribute        self.age = age    def speak(self, sound):        return f\"{self.name} says {sound}\""
      },
      {
        "type": "h1",
        "content": "Creating an Object"
      },
      {
        "type": "p",
        "content": "An object is an instance of a class created by calling the class."
      },
      {
        "type": "pre",
        "content": "buddy = Dog(\"Buddy\", 5)print(buddy.speak(\"Woof\"))"
      },
      {
        "type": "h1",
        "content": "4. Designing Reusable Classes and Creating Objects"
      },
      {
        "type": "p",
        "content": "When designing classes in Python, you should aim to make them reusable. A well-designed class encapsulates all the data and methods necessary for the object to work, while also providing a clear and simple interface for interacting with that object."
      },
      {
        "type": "h1",
        "content": "A Practical Example: Creating a Bank Account Class"
      },
      {
        "type": "pre",
        "content": "class BankAccount:    def __init__(self, balance=0):        self.balance = balance    def deposit(self, amount):        self.balance += amount        return self.balance    def withdraw(self, amount):        if amount > self.balance:            raise ValueError(\"Insufficient funds\")        self.balance -= amount        return self.balance    def get_balance(self):        return self.balance"
      },
      {
        "type": "p",
        "content": "This BankAccount class can be reused to create multiple bank account objects, each with its own balance and operations."
      },
      {
        "type": "h1",
        "content": "5. Inheritance and Polymorphism in Python"
      },
      {
        "type": "p",
        "content": "Inheritance and polymorphism are two mechanisms that facilitate code reusability and the ability to extend existing code."
      },
      {
        "type": "h1",
        "content": "Inheritance in Python"
      },
      {
        "type": "p",
        "content": "Classes in Python can inherit from other classes, allowing for the extension and customization of the inherited class‚Äôs behavior."
      },
      {
        "type": "pre",
        "content": "class SavingsAccount(BankAccount):    interest_rate = 0.02  # Additional property    def apply_interest(self):        interest = self.balance * self.interest_rate        self.deposit(interest)"
      },
      {
        "type": "h1",
        "content": "Polymorphism in Python"
      },
      {
        "type": "p",
        "content": "Polymorphism allows for the use of a shared interface, even though different objects may implement this interface in different ways."
      },
      {
        "type": "pre",
        "content": "accounts = [BankAccount(1000), SavingsAccount(2000)]for account in accounts:    print(f\"Balance: {account.get_balance()}\")    if isinstance(account, SavingsAccount):        account.apply_interest()    print(f\"New Balance: {account.get_balance()}\")"
      },
      {
        "type": "h1",
        "content": "6. Exceptions as Objects in Python"
      },
      {
        "type": "p",
        "content": "In Python, exceptions are treated as objects. This allows for the handling of errors in a more flexible way using try-except blocks."
      },
      {
        "type": "pre",
        "content": "try:    account = BankAccount(-1000)  # Attempt to create an account with a negative balanceexcept ValueError as e:    print(f\"Error: {e}\")"
      },
      {
        "type": "p",
        "content": "This is just a brief overview of the rich and complex world of OOP in Python. The best way to learn OOP is by practicing writing your own classes, creating objects, and implementing inheritance and polymorphism. Remember to consider the principles of good class design, such as encapsulation and abstraction, as you work."
      },
      {
        "type": "p",
        "content": "I hope this material serves as a solid foundation for your journey into Python‚Äôs OOP. Happy coding!"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:38.357775"
  },
  {
    "url": "https://medium.com/pythoneers/mastering-the-art-of-object-oriented-programming-in-python-df04c83cc15b",
    "title": "The Art of Object-Oriented Programming in Python!",
    "author": "",
    "published_date": null,
    "reading_time": "8 min read",
    "tags": [],
    "content": [
      {
        "type": "p",
        "content": "Member-only story"
      },
      {
        "type": "h1",
        "content": "The Art of Object-Oriented Programming in Python!"
      },
      {
        "type": "h2",
        "content": "By using Object-Oriented Programming (OOP), you can create elegant, dynamic, and robust code with Python."
      },
      {
        "type": "p",
        "content": "Aarafat Islam"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "The Pythoneers"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "1"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "blockquote",
        "content": "‚ÄúObject-oriented programming offers a sustainable way to write spaghetti code.‚Äù ‚Äî Paul Graham"
      },
      {
        "type": "p",
        "content": "‚ÄúObject-oriented programming offers a sustainable way to write spaghetti code.‚Äù ‚Äî Paul Graham"
      },
      {
        "type": "p",
        "content": "Object-oriented programming (OOP) is a programming paradigm that is based on the concept of ‚Äúobjects‚Äù, which can contain data and code that manipulates that data. In Python, OOP is supported through classes and objects."
      },
      {
        "type": "h1",
        "content": "Class and object"
      },
      {
        "type": "p",
        "content": "A class is a blueprint for creating objects (a particular data structure), providing initial values for state (member variables or attributes), and implementations of behavior (member functions or methods). A class can also define class variables and class methods, which are shared by all instances of the class."
      },
      {
        "type": "p",
        "content": "In Python, classes are defined using the class keyword, and a basic class definition might look like this:"
      },
      {
        "type": "pre",
        "content": "class MyClass:    x = 5        def print_x(self):        print(self.x)"
      },
      {
        "type": "p",
        "content": "This class, called MyClass, defines a class variable x with the value of 5, and a class method print_x() which will print the value of x when called."
      },
      {
        "type": "p",
        "content": "Creating an object, or an instance of a class, is done by calling the class name as if it were a function:"
      },
      {
        "type": "pre",
        "content": "obj = MyClass()"
      },
      {
        "type": "p",
        "content": "This will create an instance of the MyClass class, which we can then use to access the class‚Äôs attributes and methods:"
      },
      {
        "type": "pre",
        "content": "obj.x = 10obj.print_x() # prints 10"
      },
      {
        "type": "p",
        "content": "Objects of the same class are created independently of each other and have their own property values."
      },
      {
        "type": "pre",
        "content": "object1 = MyClass()object2 = MyClass()object1.x = 15print(object2.x) # prints 5"
      },
      {
        "type": "p",
        "content": "To put it simply, a class is like a blueprint of a house and an object is like a house built from that blueprint. The blueprint (class) can be used to build any number of houses (objects), but each house will have its own unique characteristics."
      },
      {
        "type": "h2",
        "content": "In Python, classes also support the following features:"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:41.213776"
  },
  {
    "url": "https://medium.com/pythoneers/9-modern-python-libraries-you-must-know-in-2025-622a36c9f30c",
    "title": "9 Modern Python Libraries You Must Know in 2025! üöÄ",
    "author": "",
    "published_date": null,
    "reading_time": "7 min read",
    "tags": [],
    "content": [
      {
        "type": "p",
        "content": "Member-only story"
      },
      {
        "type": "h2",
        "content": "LEVEL UP YOUR PYTHON SKILLS WITH THESE"
      },
      {
        "type": "h1",
        "content": "9 Modern Python Libraries You Must Know in 2025! üöÄ"
      },
      {
        "type": "h2",
        "content": "I have discovered these few game changer modern set of libraries that you should must know in 2025."
      },
      {
        "type": "p",
        "content": "Aashish Kumar"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "The Pythoneers"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "3"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "Hey Everyone, as we know python has a vast set of amazing libraries and many of them are really a game changer."
      },
      {
        "type": "p",
        "content": "So, i have discovered these few game changer modern set of libraries that you should must know if you want to stay ahead in 2025."
      },
      {
        "type": "blockquote",
        "content": "So i have discovered 100 essential Python libraries that can help to supercharge your project, Please check this out"
      },
      {
        "type": "p",
        "content": "So i have discovered 100 essential Python libraries that can help to supercharge your project, Please check this out"
      },
      {
        "type": "h2",
        "content": "100 Essential Python Libraries to Supercharge Your Projects üöÄ ‚Äî From AI to Web Development!"
      },
      {
        "type": "h3",
        "content": "I have discovered 100 essential Python libraries that can help to supercharge your project."
      },
      {
        "type": "p",
        "content": "medium.com"
      },
      {
        "type": "h1",
        "content": "1. Polars ‚Äî The Blazing-Fast DataFrame Library"
      },
      {
        "type": "p",
        "content": "Polars is a blazingly fast DataFrame library written in Rust for manipulating structured data."
      },
      {
        "type": "blockquote",
        "content": "Why You Should Use It: This is 10x‚Äì100x faster than Pandas. It Supports lazy evaluation for large datasets and works natively with Apache ArrowDocs : https://docs.pola.rs/"
      },
      {
        "type": "p",
        "content": "Why You Should Use It: This is 10x‚Äì100x faster than Pandas. It Supports lazy evaluation for large datasets and works natively with Apache Arrow"
      },
      {
        "type": "p",
        "content": "Docs : https://docs.pola.rs/"
      },
      {
        "type": "h2",
        "content": "Installation"
      },
      {
        "type": "pre",
        "content": "pip install polars"
      },
      {
        "type": "h2",
        "content": "Example"
      },
      {
        "type": "p",
        "content": "This is simple example to create a DataFrame using Polars:"
      },
      {
        "type": "pre",
        "content": "import polars as plimport datetime as dtdf = pl.DataFrame(    {        \"name\": [\"Alice Archer\", \"Ben Brown\", \"Chloe Cooper\", \"Daniel Donovan\"],        \"birthdate\": [            dt.date(1997, 1, 10),            dt.date(1985, 2, 15),            dt.date(1983, 3, 22),            dt.date(1981, 4, 30),        ],        \"weight\": [57.9, 72.5, 53.6, 83.1],  # (kg)        \"height\": [1.56, 1.77, 1.65, 1.75],  # (m)    })print(df)"
      },
      {
        "type": "pre",
        "content": "shape: (4, 4)‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ name           ‚îÜ birthdate  ‚îÜ weight ‚îÜ height ‚îÇ‚îÇ ‚Ä¶"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:43.328726"
  },
  {
    "url": "https://python.plainenglish.io/learning-class-inheritance-in-object-oriented-programming-with-python-in-10-minutes-7321b43d6c78",
    "title": "Learning Inheritance in Object-Oriented Programming with Python",
    "author": "206 Following",
    "published_date": null,
    "reading_time": "6 min read",
    "tags": [],
    "content": [
      {
        "type": "p",
        "content": "Member-only story"
      },
      {
        "type": "h1",
        "content": "Learning Inheritance in Object-Oriented Programming with Python"
      },
      {
        "type": "p",
        "content": "Chris Kuo/Dr. Dataman"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "Python in Plain English"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "2"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "In ‚ÄúLearning Object-Orient Programming with Python in 10 Minutes‚Äù, I use a cookie-cutter idea to explain the concept of object-oriented programming (OOP). Many readers like that analogy. If you have not read the previous article, I strongly encourage you to read it first. In this article, I continue to use the cookie-cutter idea to explain an important technique ‚ÄúInheritance‚Äù in OOP. Once you understand it, you will read other classes comfortably and write your classes more efficiently."
      },
      {
        "type": "p",
        "content": "In this article, I also introduce the Unified Modeling Language (UML) Diagram. A UML diagram visualizes the relationships between multiple classes and what each of them contains. When a system has many classes and becomes complex, the UML diagram ‚Äî a standard communicative language, is particularly helpful for software development. If this is the first time you heard of UML, I hope you will become familiar with this popular visualization tool. More references are included at the end of the article."
      },
      {
        "type": "h2",
        "content": "A ‚ÄúClass‚Äù Is Like a multi-function Cookie Cutter"
      },
      {
        "type": "p",
        "content": "Let me reiterate the cookie-cutter idea. Assume you are making cookies of different sizes. You can use large or small cookie cutters, or just use one adjustable cookie cutter. Wouldn‚Äôt it be convenient if you have one multi-function cookie cutter in your kitchen rather than cutters of various sizes? That‚Äôs the idea. A ‚Äúclass‚Äù is a multi-function cookie cutter that can produce objects of many variations with basically the same property. The objects here are the yummy cookies that my kids love. My wife, on the other hand, cares if she has an efficient and repeatable working procedure to make cookies. She would like to spend time to custom-make a good multi-function cookie cutter for all purposes. In programming, we do not want to write cumbersome code to declare objects one by one (imagine there are hundreds of similar objects to declare). We would rather spend time designing a toolkit, called a class, that can produce many objects with some variations. I compare a class to a toolkit and just want to emphasize that a class can do something."
      },
      {
        "type": "h2",
        "content": "Inheritance"
      },
      {
        "type": "p",
        "content": "Suppose now my wife needs to make donuts for the kids. A donut cutter is similar to a cookie cutter‚Ä¶"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:46.633665"
  },
  {
    "url": "https://www.google.com/url?sa=t&source=web&rct=j&opi=89978449&url=https://medium.com/%40ericapantojacs/file-handling-in-python-efcfe94aa9a3&ved=2ahUKEwj3xqeojbCMAxVAyTgGHSzMLHkQFnoECCMQAQ&usg=AOvVaw3foQ4cjAsiUydhLnmUMg9G",
    "title": "Unknown Title",
    "author": "Unknown Author",
    "published_date": null,
    "reading_time": "Unknown",
    "tags": [],
    "content": [],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:48.816974"
  },
  {
    "url": "https://medium.com/@rahulkp220/list-comprehensions-lambda-filter-map-and-reduce-functions-in-python-d7a1bc6cd79d",
    "title": "List Comprehensions, lambda, filter, map and reduce functions in Python",
    "author": "",
    "published_date": null,
    "reading_time": "4 min read",
    "tags": [
      "Python",
      "List"
    ],
    "content": [
      {
        "type": "h1",
        "content": "List Comprehensions, lambda, filter, map and reduce functions in Python"
      },
      {
        "type": "p",
        "content": "Rahul Lakhanpal"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "1"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "For a complete newbie, using these functions is not usual, unless they discover about them one day.Well this post is intended to make readers get their hands down and dirty with all of these."
      },
      {
        "type": "h1",
        "content": "List Comprehensions"
      },
      {
        "type": "p",
        "content": "To start with, List comprehension provide a ‚Äúshorthand‚Äù way to create lists.Didn‚Äôt get me? Ohk, how will you print 10 numbers starting from 0 in the form of a list? You would do something like this."
      },
      {
        "type": "pre",
        "content": ">>>my_list = []>>>for i in range(10):       my_list.append(i)"
      },
      {
        "type": "p",
        "content": "Seems very easy and you may have done or seen this numerous times.What if I did this.."
      },
      {
        "type": "pre",
        "content": ">>>my_list = [i for i in range(10)]"
      },
      {
        "type": "p",
        "content": "Feels fresh? Certainly yes and looks more ‚ÄúPythonic‚Äù too."
      },
      {
        "type": "p",
        "content": "Although the code which you typed in initially wasn't wrong, but then this one adds more beauty to the code."
      },
      {
        "type": "p",
        "content": "Hmm, so Let‚Äôs look up some more code which will show you the power of list comprehensions."
      },
      {
        "type": "p",
        "content": "Printing the cube of all numbers in a list starting from 1 to 10."
      },
      {
        "type": "pre",
        "content": ">>> output_list = [i**3 for i in range(1,11)]>>> print output_list[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]"
      },
      {
        "type": "p",
        "content": "Printing all the names in the list in lowercase."
      },
      {
        "type": "pre",
        "content": ">>> output_list = [i.lower() for i in [‚ÄúRAHUL‚Äù,‚ÄùLAKHANPAL‚Äù]]>>> print output_list[‚Äòrahul‚Äô, ‚Äòlakhanpal‚Äô]"
      },
      {
        "type": "p",
        "content": "Apart from doing simple operations, we can do a lot more.Suppose we wanted to use conditionals on list, yeah the same if else blocks?"
      },
      {
        "type": "p",
        "content": "Print all the odd numbers of a list starting from 2 to 12."
      },
      {
        "type": "pre",
        "content": ">>> output_list = [i for i in range(2,13) if i%2==0]>>> print output_list[2, 4, 6, 8, 10, 12]"
      },
      {
        "type": "p",
        "content": "Pretty Easy!Ohk, now lets move on to the Complex stuff."
      },
      {
        "type": "p",
        "content": "Many a times, you would have a data structure which will be like a lists of lists. or in other terms a Nested List Comprehension.For instance,"
      },
      {
        "type": "pre",
        "content": "my_list = [[1,2],[3,4],[5,6],[7,8]]"
      },
      {
        "type": "p",
        "content": "And we want to have this flattened, or in another terms open up the list.Again without using list comprehensions,"
      },
      {
        "type": "pre",
        "content": ">>>final_list = []>>>for i in mylist:       for j in i:           final_list.append(j)>>> print final_list[1, 2, 3, 4, 5, 6, 7, 8]"
      },
      {
        "type": "p",
        "content": "Going back to what we learned in list comprehensions, we would do something of this sort."
      },
      {
        "type": "pre",
        "content": ">>>my_list = [[1,2],[3,4],[5,6],[7,8]]>>>final_list = [j for i in my_list for j in i]>>>print final_list[1, 2, 3, 4, 5, 6, 7, 8]>>>"
      },
      {
        "type": "p",
        "content": "The expression [j for i in my_list for j in i] can be broken down as:[value for inner_list in outer_list for value in inner_list]"
      },
      {
        "type": "p",
        "content": "Now that we have made ourselves comfortable with List comprehensions, we are ready to move towards our main topics.lambda()filter()map()reduce()"
      },
      {
        "type": "h1",
        "content": "lambda functions"
      },
      {
        "type": "h2",
        "content": "These are the functions which we can generate on the fly and are inline functions with ready-to-use capability."
      },
      {
        "type": "p",
        "content": "Unlike the usual function syntax, which uses ‚Äúdef‚Äù to define a function, here we use lambda.Let‚Äôs see a few examples."
      },
      {
        "type": "pre",
        "content": ">>>#Function to print the squares of any number>>> my_function = lambda x: x**2>>> my_function(10)100>>>#Function to print True is number greater than 10 >>> my_function = lambda x: ‚ÄúTrue‚Äù if x>10 else ‚ÄúFalse‚Äù>>> my_function(10)‚ÄòFalse‚Äô"
      },
      {
        "type": "h1",
        "content": "filter(),map() and reduce()"
      },
      {
        "type": "h2",
        "content": "All these 3 functions follow a similar kind of syntax in terms of arguments they take."
      },
      {
        "type": "p",
        "content": "For instance, the first parameter is a list and the second parameter is a function that has to be applied over every iterable on that list.Lets walk through an example."
      },
      {
        "type": "pre",
        "content": "my_list = [0,1,2,3,4,5,6]"
      },
      {
        "type": "p",
        "content": "map() function maps the function call on every element of the list.Here map() applies the function lambda x: x+1 on my_list elements,which increments each element by 1.The output is always a list of the same length as of the parent list."
      },
      {
        "type": "pre",
        "content": ">>> map(lambda x: x+1,my_list)[1, 2, 3, 4, 5, 6, 7]"
      },
      {
        "type": "p",
        "content": "filter() function does the same but the difference being that it filters out those elements which satisfy a specific condition.Here lambda x: x>2 and x<5 function takes in only those values out from my_list which satisfy the given criteria.Again the result is a list with elements equal to or less than the original list."
      },
      {
        "type": "pre",
        "content": ">>> filter(lambda x: x>2 and x<5,my_list)[3, 4]"
      },
      {
        "type": "p",
        "content": "reduce() function behaves differently in a way that it just outputs a single numerical value.Here it applies the lambda function which takes 2 values and adds them."
      },
      {
        "type": "pre",
        "content": ">>> reduce(lambda x,y: x+y,my_list)21"
      },
      {
        "type": "p",
        "content": "This additions happens in this manner.0+1 = 11+2 = 33+4 = 77+5 = 1212+7 = 21"
      },
      {
        "type": "p",
        "content": "So, you see, the sum of first two digits is added to the third in the list in this case."
      },
      {
        "type": "p",
        "content": "Note:The function reduce() was moved to functools module in Python 3."
      },
      {
        "type": "p",
        "content": "Hope the above article was useful and explanatory to an extent."
      },
      {
        "type": "h2",
        "content": "Happy Coding!"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:52.038766"
  },
  {
    "url": "https://medium.com/swlh/iterators-and-generators-96e76eb27219",
    "title": "Iterators and Generators",
    "author": "",
    "published_date": null,
    "reading_time": "5 min read",
    "tags": [
      "Python Generators",
      "Iterators",
      "Python",
      "Iterables",
      "Learning"
    ],
    "content": [
      {
        "type": "h1",
        "content": "Iterators and Generators"
      },
      {
        "type": "p",
        "content": "Vignesh Jeyaraman"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "The Startup"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "Iterators and Generators are two ways of working with iterables efficiently in Python. They provide memory efficient solution for working with List, string, tuples, etc."
      },
      {
        "type": "p",
        "content": "To prove this point lets do a small experiment."
      },
      {
        "type": "p",
        "content": "Open your terminal and write below line"
      },
      {
        "type": "pre",
        "content": "list(range(10**10))"
      },
      {
        "type": "p",
        "content": "Oops does your terminal hang? Hahaha please don‚Äôt curse I have done this to show what is wrong with the above line of code. Your terminal was hanged because the above line was trying to load all the values in memory, in one go, and since memory is limited it got hanged."
      },
      {
        "type": "p",
        "content": "We can re-write the above line as"
      },
      {
        "type": "pre",
        "content": "a = iter(range(10**10))"
      },
      {
        "type": "p",
        "content": "You can believe me now it won‚Äôt cause any trouble :P. iter returns the object of iterator and now your terminal won‚Äôt hang because iterator won‚Äôt load all the values instead it loads only one and remember its state. This is called lazy evaluation which simply means that value will only be returned if it is asked. There are two ways to access the values in the iterator object either write a for loop to loop through the values or next(a) to print one value at a time."
      },
      {
        "type": "p",
        "content": "You can convert any iterable(list, tuple, string) into iterator object using iter function."
      },
      {
        "type": "blockquote",
        "content": "To use iter function you should pass iterable as an argument to it."
      },
      {
        "type": "p",
        "content": "To use iter function you should pass iterable as an argument to it."
      },
      {
        "type": "p",
        "content": "Now, you will be thinking about how can we write our own iterator and my friends this is where the generator outpower the iterator because writing a custom iterator is somewhat a difficult task you have to override __iter__ and __next__ dunder method to write custom iterator."
      },
      {
        "type": "p",
        "content": "Below is an example of the custom iterator class."
      },
      {
        "type": "pre",
        "content": "class A:...     def __init__(self, end=0):...             self.end = end...     def __iter__(self):...             self.i = 0...             return self...     def __next__(self):...             if self.i < self.end:...                     result = self.i...                     self.i += 1...                     return result...             else:...                     raise StopIteration"
      },
      {
        "type": "p",
        "content": "Don‚Äôt think about stop iteration we will discuss it shortly. So, above we have written a custom iterator you can see that we have overridden __iter__ and __next__ this is what makes our class an iterable just like a list, tuple, etc."
      },
      {
        "type": "p",
        "content": "Now to use this we have to write the below lines."
      },
      {
        "type": "pre",
        "content": "a = A(3)i = iter(a)next(i)"
      },
      {
        "type": "p",
        "content": "Since we initialized class with 3 so after 3 consecutive calls to next it will raise a stop iteration exception."
      },
      {
        "type": "p",
        "content": "To create a custom iterator we have to write a class with __iter__ and __next__ dunder method and I know it is a bit complicated task."
      },
      {
        "type": "p",
        "content": "Its best replacement is generator writing a custom generator is far easy and it can be done by writing a function definition with the yield statement. The generator can have multiple yield statements."
      },
      {
        "type": "blockquote",
        "content": "Remember all generaator are iterator but vice versa is not true."
      },
      {
        "type": "p",
        "content": "Remember all generaator are iterator but vice versa is not true."
      },
      {
        "type": "p",
        "content": "Let‚Äôs write a custom generator."
      },
      {
        "type": "pre",
        "content": "def A():    a = 0    yield a    a += 1    yield a    a += 1    yield agen = A()next(gen)"
      },
      {
        "type": "p",
        "content": "If you check the type of gen it will print generator and python knows it is a generator because of the yield keyword."
      },
      {
        "type": "h1",
        "content": "Yield vs Return"
      },
      {
        "type": "p",
        "content": "So, one of the famous questions asked in the interview, what is the difference between yield and return. Let‚Äôs learn about it."
      },
      {
        "type": "pre",
        "content": "def A():    a = [1,2,3,4]    for i in a:        return i"
      },
      {
        "type": "p",
        "content": "What do you think the above program will do?? You guessed it right, it will kill the function as soon as it sees a return statement well kill is not a right word to use we can say that python will stop function‚Äôs execution as soon as it sees a return statement."
      },
      {
        "type": "p",
        "content": "Let‚Äôs re-write the above function with a yield statement"
      },
      {
        "type": "pre",
        "content": "def A():    a = [1,2,3,4]    for i in a:        yield i"
      },
      {
        "type": "p",
        "content": "Now here is the interesting part as soon as python sees yield statement it becomes happy and don‚Äôt stop function execution instead it pauses its execution and remember the state and when you call next it will print all elements one by one till all of them get exhausted after that it will raise a stop iteration exception."
      },
      {
        "type": "blockquote",
        "content": "Just remember when we use yield program remembers where it stoped and when we call next again it continues execution from there."
      },
      {
        "type": "p",
        "content": "Just remember when we use yield program remembers where it stoped and when we call next again it continues execution from there."
      },
      {
        "type": "p",
        "content": "Let‚Äôs see one more example"
      },
      {
        "type": "pre",
        "content": "def A():    a = 0    yield a    a += 1    yield a    a += 1    yield aa = A()"
      },
      {
        "type": "p",
        "content": "When you run next(a) it will pause on first yield and print 0 when you call next(a) again it will pause on second yield and print 1 and so on and when all yield gets exhausted then it will raise stop iteration exception."
      },
      {
        "type": "h1",
        "content": "StopIteration Exception"
      },
      {
        "type": "p",
        "content": "So let‚Äôs discuss the last topic of this article which is StopIteration exception."
      },
      {
        "type": "p",
        "content": "Whenever either all the yield statements or all the values in iterables get exhausted, the generator, as well as iterator, raises the StopIteration exception. When we call next manually we have to handle them ourselves like below."
      },
      {
        "type": "pre",
        "content": "def A():    a = 0    yield atemp = A()try:    next(temp)    next(temp)except StopIteration as ex:    print(\"All values are exhausted\")"
      },
      {
        "type": "p",
        "content": "It will print"
      },
      {
        "type": "pre",
        "content": "0All values are exhausted"
      },
      {
        "type": "p",
        "content": "You must be wondering that when we loop through iterable using a for loop we don‚Äôt handle anything like this that is because for loop itself handles it for us."
      },
      {
        "type": "p",
        "content": "That‚Äôs all for this article. Next, let‚Äôs explore itertools which is provided by python and it has lots of amazing inbuilt functions using which we can write optimized code."
      },
      {
        "type": "blockquote",
        "content": "I have read a lot of blogs before writing this article. It would be really great if anyone can share more on this and correct me if I am wrong anywhere."
      },
      {
        "type": "p",
        "content": "I have read a lot of blogs before writing this article. It would be really great if anyone can share more on this and correct me if I am wrong anywhere."
      },
      {
        "type": "p",
        "content": "As always let learn together and grow together. See you soon!!"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:55.407428"
  },
  {
    "url": "https://medium.com/@chanataranjeet/understanding-python-decorators-a-concise-guide-eac4a19eb982",
    "title": "Understanding Python Decorators: A Concise Guide",
    "author": "",
    "published_date": null,
    "reading_time": "2 min read",
    "tags": [
      "Machine Learning",
      "Artificial Intelligence",
      "Deep Learning",
      "Python"
    ],
    "content": [
      {
        "type": "h1",
        "content": "Understanding Python Decorators: A Concise Guide"
      },
      {
        "type": "p",
        "content": "Taranjeet Singh Chana"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "Python decorators are a powerful aspect of the language that allow you to modify the behavior of functions or methods. They are functions themselves that wrap around another function, enabling you to add functionality to existing code without modifying it. Let‚Äôs dive into decorators with a simple example."
      },
      {
        "type": "h2",
        "content": "What Are Decorators?"
      },
      {
        "type": "p",
        "content": "Decorators in Python use the @decorator_function syntax and are essentially functions that take another function as an argument and return a new function. They help in modifying or enhancing the behavior of the original function."
      },
      {
        "type": "h2",
        "content": "Example: Creating a Decorator"
      },
      {
        "type": "pre",
        "content": "# Define a decorator functiondef my_decorator(func):    def wrapper():        print(\"Something is happening before the function is called.\")        func()        print(\"Something is happening after the function is called.\")    return wrapper# Apply the decorator using '@'@my_decoratordef say_hello():    print(\"Hello!\")# Call the decorated functionsay_hello()"
      },
      {
        "type": "p",
        "content": "Output:"
      },
      {
        "type": "pre",
        "content": "Something is happening before the function is called.Hello!Something is happening after the function is called."
      },
      {
        "type": "h2",
        "content": "Explanation:"
      },
      {
        "type": "h2",
        "content": "Conclusion:"
      },
      {
        "type": "p",
        "content": "Decorators are a versatile tool in Python that enable you to modify the behavior of functions without changing their actual code. They are widely used in frameworks like Flask and Django for tasks such as authentication, logging, and more. Understanding decorators can greatly enhance your ability to write clean, reusable, and efficient code."
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T01:59:58.588413"
  },
  {
    "url": "https://medium.com/@dealiraza/using-external-libraries-in-python-dba5087de047",
    "title": "Using External Libraries in Python",
    "author": "",
    "published_date": null,
    "reading_time": "4 min read",
    "tags": [],
    "content": [
      {
        "type": "p",
        "content": "Member-only story"
      },
      {
        "type": "h1",
        "content": "Using External Libraries in Python"
      },
      {
        "type": "p",
        "content": "Ali Raza"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "This article delves into the essentials of using external libraries in Python, covering their installation, management, usage, and best practices."
      },
      {
        "type": "p",
        "content": "Python‚Äôs strength lies in its rich ecosystem of external libraries which extend its functionality to cover a vast range of applications. These libraries enable developers to perform tasks like data analysis, web development, machine learning, scientific computation, and more with minimal effort. By leveraging external libraries programmers can save time and focus on solving problems rather than reinventing the wheel."
      },
      {
        "type": "h1",
        "content": "1. Introduction to External Libraries"
      },
      {
        "type": "p",
        "content": "An external library is a collection of pre-written Python code designed to solve specific problems or provide additional features. Unlike Python‚Äôs standard library external libraries are developed by the community or organizations and are not included in the default Python installation."
      },
      {
        "type": "h2",
        "content": "1.1 Examples of Popular Libraries"
      },
      {
        "type": "h2",
        "content": "1.2 Benefits of External Libraries"
      },
      {
        "type": "h1",
        "content": "2. Installing External Libraries"
      },
      {
        "type": "p",
        "content": "Python uses package managers like pip to install external libraries. These tools fetch libraries from repositories such as the Python Package Index (PyPI) and make them available for use in your environment."
      },
      {
        "type": "h2",
        "content": "2.1 Using pip"
      },
      {
        "type": "p",
        "content": "The pip tool is the default package manager for Python. Here‚Äôs how to install a library using pip:"
      },
      {
        "type": "pre",
        "content": "pip install library_name"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T02:00:01.489095"
  },
  {
    "url": "https://learncsdesigns.medium.com/understanding-concurrency-parallelism-in-python-b952a778873d",
    "title": "Understanding Concurrency & Parallelism In Python",
    "author": "Press",
    "published_date": null,
    "reading_time": "7 min read",
    "tags": [
      "Python",
      "Programming",
      "Coding",
      "Software Development",
      "Datastrucutre"
    ],
    "content": [
      {
        "type": "h1",
        "content": "Understanding Concurrency & Parallelism In Python"
      },
      {
        "type": "p",
        "content": "Neeraj Kushwaha"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "blockquote",
        "content": "This is the 9th post in a series of learning the Python programming language."
      },
      {
        "type": "p",
        "content": "This is the 9th post in a series of learning the Python programming language."
      },
      {
        "type": "p",
        "content": "Concurrency and parallelism are two related but distinct concepts in computer science. Concurrency refers to the ability of a program to handle multiple tasks at the same time, while parallelism refers to the ability of a program to execute multiple tasks simultaneously, usually on separate cores or processors."
      },
      {
        "type": "h1",
        "content": "Concurrency"
      },
      {
        "type": "p",
        "content": "In Python, concurrency can be achieved using the threading module, which provides a way to create and manage threads. A thread is a separate execution flow within a program and can be used to run tasks concurrently with the main program."
      },
      {
        "type": "p",
        "content": "Here‚Äôs an example of using threads to download multiple files concurrently:"
      },
      {
        "type": "pre",
        "content": "import threadingimport urllib.requestimport osdef download_file(url, semaphore):    \"\"\"Download a file from the given url\"\"\"    try:        with semaphore:            filename = url.split('/')[-1]            if os.path.exists(filename):                print(f\"{filename} already exists. Skipping...\")                return            print(f\"Downloading {filename}...\")            opener = urllib.request.build_opener()            opener.addheaders = [('User-agent', 'Mozilla/5.0')]            urllib.request.install_opener(opener)            urllib.request.urlretrieve(url, filename)            print(f\"{filename} downloaded.\")    except Exception as e:        print(f\"Failed to download {filename}: {e}\")# list of files to downloadurls = [    \"https://filesamples.com/samples/document/txt/sample1.txt\",    \"https://filesamples.com/samples/document/txt/sample2.txt\",    \"https://filesamples.com/samples/document/txt/sample3.txt\"]# Semaphore to limit the number of parallel downloadssemaphore = threading.Semaphore(2)# create a list of threadsthreads = []for url in urls:    t = threading.Thread(target=download_file, args=(url, semaphore))    threads.append(t)    t.start()# wait for all threads to finishfor t in threads:    t.join()"
      },
      {
        "type": "p",
        "content": "This code downloads multiple files from the URLs in the urls list using multiple threads, with some optimizations to handle corner cases and synchronization issues."
      },
      {
        "type": "h1",
        "content": "Parallelism"
      },
      {
        "type": "p",
        "content": "multiprocessing is a module in Python that provides tools to write concurrent, parallel programs. The module allows you to write parallel programs that take advantage of multiple CPU cores in your system. This makes it possible to write fast, efficient programs that can perform multiple tasks at the same time."
      },
      {
        "type": "p",
        "content": "The main component of the multiprocessing module is the Process class. The Process class is used to create new processes in your Python program. Each process created with the Process class runs as a separate entity and has its own memory space, making it possible to run multiple processes in parallel."
      },
      {
        "type": "p",
        "content": "Here‚Äôs a simple example that demonstrates the use of the multiprocessing module to run multiple processes to calculate the sum of a list of numbers. The list of numbers is split into chunks and assigned to each process. The result of each process is stored in a shared Value object, which is managed by a Manager. The shared result is protected by a lock to avoid race conditions. After all the processes have finished executing, the final result is printed."
      },
      {
        "type": "pre",
        "content": "from multiprocessing import Process, Manager, Lockdef calculate_sum(numbers, result, lock):    \"\"\"Calculate the sum of a list of numbers\"\"\"    local_sum = sum(numbers)    with lock:        result.value += local_sumdef main():    # list of numbers to sum    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]    # create a manager to share the result between processes    manager = Manager()    result = manager.Value('i', 0)    lock = Lock()    # create a list of processes    processes = []    chunk = len(numbers) // 2    for i in range(0, len(numbers), chunk):        p = Process(target=calculate_sum, args=(numbers[i:i+chunk], result, lock))        processes.append(p)        p.start()    # wait for all processes to finish    for p in processes:        p.join()    # print the result    print(result.value)if __name__ == \"__main__\":    main()"
      },
      {
        "type": "h1",
        "content": "Locks & Semaphores"
      },
      {
        "type": "h2",
        "content": "Locks"
      },
      {
        "type": "p",
        "content": "In Python, locks and semaphores are used to synchronize access to shared resources when working with threads or processes."
      },
      {
        "type": "p",
        "content": "A lock is a synchronization primitive that can be in one of two states: locked or unlocked. When a lock is locked, any other thread or process trying to acquire the lock will be blocked until it is released. Locks are typically used to protect shared resources that can be accessed by multiple threads or processes, such as a shared data structure or a file."
      },
      {
        "type": "p",
        "content": "Here‚Äôs an example of using a lock to protect access to a shared list:"
      },
      {
        "type": "pre",
        "content": "import threading# shared listnumbers = []# lock to protect access to the shared listlock = threading.Lock()def add_number(n):    \"\"\"Add a number to the shared list\"\"\"    # acquire the lock    lock.acquire()    numbers.append(n)    # release the lock    lock.release()# create two threadst1 = threading.Thread(target=add_number, args=(1,))t2 = threading.Thread(target=add_number, args=(2,))# start the threadst1.start()t2.start()# wait for the threads to finisht1.join()t2.join()# print the final state of the shared listprint(numbers)"
      },
      {
        "type": "h2",
        "content": "Semaphores"
      },
      {
        "type": "p",
        "content": "A semaphore is similar to a lock, but it allows for multiple threads or processes to acquire the semaphore at the same time, up to a certain limit. Semaphores are typically used to limit the number of threads or processes that can access a shared resource at the same time."
      },
      {
        "type": "p",
        "content": "Here‚Äôs an example of using a semaphore to limit the number of threads that can access a shared list:"
      },
      {
        "type": "pre",
        "content": "import threading# shared listnumbers = []# semaphore to limit access to the shared listsem = threading.Semaphore(value=2)def add_number(n):    \"\"\"Add a number to the shared list\"\"\"    # acquire the semaphore    sem.acquire()    numbers.append(n)    # release the semaphore    sem.release()# create four threadst1 = threading.Thread(target=add_number, args=(1,))t2 = threading.Thread(target=add_number, args=(2,))t3 = threading.Thread(target=add_number, args=(3,))t4 = threading.Thread(target=add_number, args=(4,))# start the threadst1.start()t2.start()t3.start()t4.start()# wait for the threads to finisht1.join()t2.join()t3.join()t4.join()# print the final state of the shared listprint(numbers)"
      },
      {
        "type": "p",
        "content": "It‚Äôs worth noting that in python Lock and Semaphore can be used for both process and threading, but to share the resources between different processes, it's necessary to use shared memory objects such as Value, Array from the multiprocessing module."
      },
      {
        "type": "h1",
        "content": "Value (multiprocessing module)"
      },
      {
        "type": "p",
        "content": "Value is used to create a shared variable that can be used to store a single value. The value can be of any type that can be pickled, such as an integer, float, or string."
      },
      {
        "type": "p",
        "content": "Here's an example of how to use Value to share a single integer value between two processes:"
      },
      {
        "type": "pre",
        "content": "from multiprocessing import Process, Valuedef increment(n):    for i in range(1000):        n.value += 1if __name__ == '__main__':    num = Value('i', 0) # create a shared integer with initial value of 0    p1 = Process(target=increment, args=(num,))    p2 = Process(target=increment, args=(num,))    p1.start()    p2.start()    p1.join()    p2.join()    print(num.value)"
      },
      {
        "type": "p",
        "content": "Since the num value is shared among two processes if you run the code the num.value will be different every time (not 2000) because we have not synchronized it using the lock."
      },
      {
        "type": "p",
        "content": "This is the updated version to handle synchronization with lock:"
      },
      {
        "type": "pre",
        "content": "from multiprocessing import Process, Value, Lockdef increment(n, lock):    for i in range(1000):        with lock:            n.value += 1if __name__ == '__main__':    num = Value('i', 0)    lock = Lock()    p1 = Process(target=increment, args=(num, lock))    p2 = Process(target=increment, args=(num, lock))    p1.start()    p2.start()    p1.join()    p2.join()    print(num.value)"
      },
      {
        "type": "h1",
        "content": "Array (multiprocessing module)"
      },
      {
        "type": "p",
        "content": "Array is used to create a shared array that can be used to store multiple values. The array can be of any type that can be used with the array module, such as an integer, float, or string."
      },
      {
        "type": "p",
        "content": "Here's an example of how to use Array to share an array of 10 integers between two processes:"
      },
      {
        "type": "pre",
        "content": "from multiprocessing import Process, Arraydef increment(n):    for i in range(1000):        n[i % 10] += 1if __name__ == '__main__':    num = Array('i', [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) # create a shared array of 10 integers    p1 = Process(target=increment, args=(num,))    p2 = Process(target=increment, args=(num,))    p1.start()    p2.start()    p1.join()    p2.join()    print(num[:])"
      },
      {
        "type": "p",
        "content": "It‚Äôs worth noting that Value and Array are only safe to use when the processes that use them are created using the multiprocessing module. Sharing memory between processes created using the multiprocessing and threading module is not safe and can lead to errors or data corruption."
      },
      {
        "type": "p",
        "content": "Additionally, when using shared memory objects, it is important to use appropriate synchronization mechanisms such as locks, and semaphores to avoid race conditions and other synchronization issues."
      },
      {
        "type": "p",
        "content": "If you like the post, don‚Äôt forget to clap. If you‚Äôd like to connect, you can find me on LinkedIn."
      },
      {
        "type": "h1",
        "content": "References:"
      },
      {
        "type": "p",
        "content": "https://www.python.org/doc/"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T02:00:04.727748"
  },
  {
    "url": "https://medium.com/@alirezazarei51/metaprogramming-unveiled-an-introductory-guide-with-examples-5c614a6b2f9f",
    "title": "Metaprogramming Unveiled: An Introductory Guide with Examples",
    "author": "",
    "published_date": null,
    "reading_time": "8 min read",
    "tags": [
      "Pythonprogramming",
      "Metaprogramming",
      "Softwaredevelopment",
      "Codingtips",
      "Developercommunity"
    ],
    "content": [
      {
        "type": "h1",
        "content": "Metaprogramming Unveiled: An Introductory Guide with Examples"
      },
      {
        "type": "p",
        "content": "Alireza Zarei"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "Unlocking the Power of Metaprogramming: A Game-Changer in Software Development!"
      },
      {
        "type": "p",
        "content": "Have you ever wondered how developers can write code that writes code? Or how software applications can adapt and evolve on the fly? Enter the fascinating world of metaprogramming ‚Äî a hidden gem in the realm of software development that‚Äôs reshaping the way we build and innovate with code."
      },
      {
        "type": "p",
        "content": "From creating dynamic frameworks to automating repetitive tasks, metaprogramming is the secret sauce that empowers developers to transcend the limits of traditional programming paradigms. Imagine a world where your code not only executes commands but also manipulates its own structure and behavior in real time. That‚Äôs the magic of metaprogramming at work!"
      },
      {
        "type": "p",
        "content": "Join us as we explore this transformative concept through practical examples that showcase its potential to reshape how we build and innovate with code."
      },
      {
        "type": "h1",
        "content": "A Closer Look at Metaprogramming Concepts"
      },
      {
        "type": "p",
        "content": "Metaprogramming is a technique of writing computer programs that can treat themselves as data, so they can introspect, generate, and/or modify themselves while running."
      },
      {
        "type": "p",
        "content": "Such a programming approach gives programmers a lot of power and flexibility."
      },
      {
        "type": "p",
        "content": "Python is especially rich in features and modules that make certain metaprogramming techniques simple and natural."
      },
      {
        "type": "p",
        "content": "we can distinguish between two major branches of metaprogramming in Python:"
      },
      {
        "type": "p",
        "content": "Introspection-oriented metaprogramming in Python leverages the language‚Äôs introspection capabilities to dynamically create or modify basic elements like functions, classes, or types, aiding real-time code analysis and name suggestions in IDEs. Key tools include decorators for enhancing existing functions, methods, or classes, followed by class methods for manipulating class instance creation. Metaclasses stand out as the most potent, enabling significant redesign of Python‚Äôs object-oriented programming implementation."
      },
      {
        "type": "p",
        "content": "Code-oriented metaprogramming empowers programmers to interact directly with code, be it in plain text or the more intricate abstract syntax tree (AST) form. While the latter is more complex, it unlocks advanced capabilities such as extending Python‚Äôs syntax or crafting domain-specific languages (DSL) for specialized tasks."
      },
      {
        "type": "h1",
        "content": "Metaprogramming in Action"
      },
      {
        "type": "p",
        "content": "Metaclasses are a great tool for doing unusual things. They give a lot of flexibility and power in modifying typical class behavior. So, it is hard to tell what common examples of their usage are. It would be easier to say that most usages of metaclasses are pretty uncommon."
      },
      {
        "type": "p",
        "content": "Let‚Äôs delve into a practical example to illustrate the power of metaprogramming in Python. Consider a scenario where you want to create a custom logger that automatically logs the inputs and outputs of a function each time it is called. Metaprogramming enables us to achieve this by using decorators to add this logging functionality without modifying the original function."
      },
      {
        "type": "pre",
        "content": "def log_function(func):    def wrapper(*args, **kwargs):        print(f\"Logging - Function '{func.__name__}' called with args: {args} and kwargs: {kwargs}\")        result = func(*args, **kwargs)        print(f\"Logging - Function '{func.__name__}' returned: {result}\")        return result    return wrapper@log_functiondef add(a, b):    return a + b@log_functiondef multiply(a, b):    return a * b# Test the functionsprint(add(3, 4))print(multiply(2, 5))"
      },
      {
        "type": "p",
        "content": "In this example, the log_function decorator wraps the original add and multiply functions, adding logging statements before and after the function calls. By applying the decorator to these functions, we seamlessly enhance their behavior to include automated logging without directly modifying their code. This showcases how metaprogramming techniques like decorators can effectively extend the functionality of existing functions in Python."
      },
      {
        "type": "h1",
        "content": "Unlocking Advanced Metaprogramming with Python‚Äôs Type Class"
      },
      {
        "type": "p",
        "content": "A metaclass is a type (class) that defines other types (classes). The most important thing to know in order to understand how they work is that classes (so, types that define object structure and behavior) are objects too. So, if they are objects, then they have an associated class. The basic type of every class definition is simply the built-in type class."
      },
      {
        "type": "p",
        "content": "In Python, it is possible to substitute the metaclass for a class object with your custom type. Usually, the new metaclass is still the subclass of the type metaclass because not doing so would make the resulting classes highly incompatible with other classes in terms of inheritance:"
      },
      {
        "type": "p",
        "content": "The call to the built-in type() class can be used as a dynamic equivalent of the class statement."
      },
      {
        "type": "p",
        "content": "The detailed call signature of a metaclass is type(name, bases, namespace) and the meaning of the arguments are as follows:"
      },
      {
        "type": "p",
        "content": "¬∑ name: This is the name of the class that will be stored in the __name__ attribute"
      },
      {
        "type": "p",
        "content": "¬∑ bases: This is the list of parent classes that will become the __bases__ attribute and will be used to construct the MRO of a newly created class"
      },
      {
        "type": "p",
        "content": "namespace: This is a namespace (mapping) with definitions for the class body that will become the __dict__ attribute"
      },
      {
        "type": "h2",
        "content": "Deep Dive into Python‚Äôs Type Class"
      },
      {
        "type": "p",
        "content": "Let‚Äôs imagine the following problem: We have a large Python code base that was developed over dozens of years and the majority of the code was written way before anyone in the team cared about coding standards. We may have, for instance, classes mixing camelCase and snake_case as the method naming convention. If we cared about consistency, we would be forced to spend a tremendous amount of effort to refactor the whole code base into either of the naming conventions. Or we could just use some clever metaclass that could be added on top of existing classes that would allow for calling methods in both ways. We could write new code using the new calling convention (preferably snake_case) while leaving the old code untouched and waiting for a gradual update."
      },
      {
        "type": "p",
        "content": "Before we proceed, we need to be familiar with the prepare dunder method."
      },
      {
        "type": "p",
        "content": "__prepare__(mcs, name, bases, **kwargs): This creates an empty namespace object. By default, it returns an empty dict instance, but it can be overridden to return any other dict subclass instance. Note that it does not accept the namespace as an argument because, before calling it, the namespace does not exist yet."
      },
      {
        "type": "p",
        "content": "OK now let‚Äôs start by writing a dict subclass that automatically interpolates camelCase names into snake_case keys:"
      },
      {
        "type": "pre",
        "content": "class CaseInterpolationDict(dict):    def __setitem__(self, key: str, value: Any):        super().__setitem__(key, value)        super().__setitem__(inflection.underscore(key), value)"
      },
      {
        "type": "p",
        "content": "Now it‚Äôs time to write an actual metaclass that will override the class namespace type. It will be surprisingly short:"
      },
      {
        "type": "pre",
        "content": "class CaseInterpolatedMeta(type):    @classmethod    def __prepare__(mcs, name, bases):        return CaseInterpolationDict()"
      },
      {
        "type": "p",
        "content": "Since we are set up, we can now use the CaseInterpolatedMeta metaclass to create a dummy class with a few methods that use the camelCase naming convention:"
      },
      {
        "type": "pre",
        "content": "class User(metaclass=CaseInterpolatedMeta):    def __init__(self, firstName: str, lastName: str):        self.firstName = firstName        self.lastName = lastName    def getDisplayName(self):        return f\"{self.firstName} {self.lastName}\"    def greetUser(self):        return f\"Hello {self.getDisplayName()}!"
      },
      {
        "type": "p",
        "content": "The first important thing to notice is the contents of the User.__dict__ attribute:"
      },
      {
        "type": "pre",
        "content": ">>> User.__dict__mappingproxy({    '__module__': 'case_class',    '__init__': <function case_class.User.__init__(self, firstName:str, lastName: str)>,    'getDisplayName': <function case_class.User.getDisplayName(self)>,    'get_display_name': <function case_class.User.getDisplayName(self)>,    'greetUser': <function case_class.User.greetUser(self)>,    'greet_user': <function case_class.User.greetUser(self)>,    '__dict__': <attribute '__dict__' of 'User' objects>,    '__weakref__': <attribute '__weakref__' of 'User' objects>,    '__doc__': None})"
      },
      {
        "type": "p",
        "content": "The first thing that catches the eye is the fact that methods got duplicated. That was exactly what we wanted to achieve. The second important thing is the fact that User.__dict__ is of the mappingproxy type. That‚Äôs because Python always copies the contents of the namespace object to a new dict when creating the final class object. The mapping proxy also allows proxy access to superclasses within the class MRO."
      },
      {
        "type": "p",
        "content": "So, let‚Äôs see if our solution works by invoking all of its methods:"
      },
      {
        "type": "pre",
        "content": ">>> user = User(\"John\", \"Doe\")>>> user.getDisplayName()'John Doe'>>> user.get_display_name()'John Doe'>>> user.greetUser()'Hello John Doe!'>>> user.greet_user()'Hello John Doe!'"
      },
      {
        "type": "h1",
        "content": "Benefits Of Using Metaprogramming"
      },
      {
        "type": "p",
        "content": "There are situations where things cannot be easily done without metaclasses. For instance, it is hard to imagine Django‚Äôs ORM implementation built without extensive use of metaclasses. It could be possible, but it is rather unlikely that the resulting solution would be similarly easy to use. Frameworks are the place where metaclasses really shine. They usually have a lot of complex internal code that is not easy to understand and follow but eventually allow other programmers to write more condensed and readable code that operates on a higher level of abstraction."
      },
      {
        "type": "h1",
        "content": "Frameworks That Utilize Metaprogramming Heavily"
      },
      {
        "type": "h1",
        "content": "Pitfall of Metaprogramming"
      },
      {
        "type": "p",
        "content": "Users should, nevertheless, be aware of some drawbacks involved with metaprogramming. A significant disadvantage to many who want to step into the world of metaprogramming is syntax. Since metaprogramming primarily creates programs that write other programs, the syntax can be quite complicated, and the learning curve for metaprogramming can be steep. Many developers may feel discouraged when beginning their metaprogramming journey."
      },
      {
        "type": "p",
        "content": "Because of the steep learning curve, metaprogramming can fall victim to incorrect use. This can result in unexpected errors, which can be difficult for the average developer to handle and cause vulnerability and risks within the system. Some of the most common errors occurring within metaprogramming include compilers being unable to recognize missing configuration constraints and invalid data resulting in unidentified exceptions."
      },
      {
        "type": "p",
        "content": "Other disadvantages to metaprogramming include the following:"
      },
      {
        "type": "h1",
        "content": "conclusion"
      },
      {
        "type": "p",
        "content": "We‚Äôve taken an exciting journey into the world of metaprogramming, uncovering its transformative potential in software development. From dynamic code manipulation to pioneering new programming paradigms, metaprogramming equips developers with powerful tools to innovate and create."
      },
      {
        "type": "p",
        "content": "Throughout our exploration, we‚Äôve dived into practical techniques like introspection-oriented approaches and code-oriented methodologies, showcasing the versatility and flexibility that metaprogramming offers."
      },
      {
        "type": "p",
        "content": "As we wrap up, let‚Äôs not forget the journey ahead. While metaprogramming promises boundless creativity and efficiency, it also demands understanding, thoughtful design, and diligent testing to navigate its complexities successfully."
      },
      {
        "type": "p",
        "content": "Share your experiences, insights, and challenges with metaprogramming in the comments below. Let‚Äôs learn and grow together as we harness the full potential of metaprogramming in our coding endeavors. Happy coding!"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T02:00:07.841086"
  },
  {
    "url": "https://medium.com/better-programming/meta-programming-in-python-7fb94c8c7152",
    "title": "Meta-Programming in Python",
    "author": "",
    "published_date": null,
    "reading_time": "4 min read",
    "tags": [
      "Python",
      "Metaprogramming",
      "Functional Programming",
      "Python Programming",
      "Programming"
    ],
    "content": [
      {
        "type": "h1",
        "content": "Meta-Programming in Python"
      },
      {
        "type": "h2",
        "content": "A short tutorial on decorators and meta-classes"
      },
      {
        "type": "p",
        "content": "Saurabh Kukade"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "Better Programming"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "4"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "Recently, I encountered a very fascinating concept which is meta-programming in Python. I would like to share my findings on this topic in this article. I hope that it may help you to wrap your head around this because they say it is a tough nut to crack."
      },
      {
        "type": "h1",
        "content": "What Is Meta-Programming?"
      },
      {
        "type": "p",
        "content": "So, in one line: ‚ÄúMeta-programming is an act of writing code that manipulates code.‚Äù"
      },
      {
        "type": "p",
        "content": "Wait, what? Yes, you read it right. Code that manipulates code. Doesn‚Äôt it sound fascinating and powerful? Well, actually it is."
      },
      {
        "type": "p",
        "content": "In the context of Python, meta-programming can be stated as: ‚ÄúMeta-programming is an act of building functions and classes that can manipulate code by modifying, wrapping existing code, or generating code.‚Äù"
      },
      {
        "type": "p",
        "content": "Meta-programming in Python can be achieved with:"
      },
      {
        "type": "p",
        "content": "Let‚Äôs get familiar with them one-by-one."
      },
      {
        "type": "h1",
        "content": "Decorators"
      },
      {
        "type": "p",
        "content": "A decorator is a way of adding new functionality to an existing function without modifying its original structure."
      },
      {
        "type": "p",
        "content": "For instance, we have these three functions:"
      },
      {
        "type": "pre",
        "content": "def add(x, y):    return x + y    def sub(x, y):    return x - y    def mul(x, y):    return x * y"
      },
      {
        "type": "p",
        "content": "Now we need to print the function name and parameter values when the function gets called. This should be applicable to all three functions above."
      },
      {
        "type": "p",
        "content": "The native way is to add print/log statements to all three functions. But this sounds like very repetitive work and we‚Äôd also need to modify each function body."
      },
      {
        "type": "pre",
        "content": "def add(x, y):    print(\"add is called with parameter {0},{1}\".format(x,y))    return x + y    def sub(x, y):    print(\"sub is called with parameter {0},{1}\".format(x,y))    return x - y    def mul(x, y):    print(\"mul is called with parameter {0},{1}\".format(x,y))    return x * y    print(add(5,3))print(sub(5,3))print(mul(5,3))*********************** output *********************add is called with parameter 5, 38sub is called with parameter 5, 32mul is called with parameter 5, 315"
      },
      {
        "type": "p",
        "content": "Can we do better? Of course we can, because by the grace of God, we are programmers and programmers are intelligent. We can achieve this by writing a decorator function and by not modifying any of the existing function body."
      },
      {
        "type": "pre",
        "content": "def my_decorator(func):    def wrapper_function(*args):        print(\"{0} is called with parameter {1}\".format(func.__name__, args))        return func(*args)    return wrapper_function@my_decoratordef add(x, y):    return x + y    @my_decoratordef sub(x, y):    return x - y@my_decorator    def mul(x, y):    return x * y *********************** output *********************add is called with parameter (5, 3)8sub is called with parameter (5, 3)2mul is called with parameter (5, 3)15"
      },
      {
        "type": "p",
        "content": "Bingo! In the above code snippet, my_decorator is a decorator function. We decorate all three functions with @my_decorator and we have not touched the existing function body to add this print functionality."
      },
      {
        "type": "p",
        "content": "So, basically, decorators are higher-order functions that take a function as an argument and returns another function. Here, my_decorator takes a function as an argument and returns wrapper_function as a result, where wrapper_function adds our print functionality to func."
      },
      {
        "type": "p",
        "content": "There is more to decorators but this is a brief introduction to decorators in Python."
      },
      {
        "type": "h1",
        "content": "Meta-Classes"
      },
      {
        "type": "p",
        "content": "Now that we‚Äôve seen decorators, they are for decorating functions. But there is more to meta-programming than decorators, such as meta-classes."
      },
      {
        "type": "p",
        "content": "Meta-classes are special types of classes, rather than ordinary classes in Python. Where an ordinary class defines behavior of its own instance, a meta-class defines the behavior of an ordinary class and its instance."
      },
      {
        "type": "p",
        "content": "A meta-class can add or subtract a method or field to an ordinary class. Python has one special class, the type class, which is by default a meta-class. All custom type classes must inherit from the type class."
      },
      {
        "type": "p",
        "content": "For instance, if we have class Calc, with three class methods, and we want to provide debug functionality to all the methods in one class then we can use a meta-class for this."
      },
      {
        "type": "pre",
        "content": "class Calc():    def add(self, x, y):        return x + y        def sub(self, x, y):        return x - y        def mul(self, x, y):        return x * y"
      },
      {
        "type": "p",
        "content": "First, we need to create a meta-class MetaClassDebug, with debug functionality, and make the Calc class inherit from MetaClassDebug."
      },
      {
        "type": "p",
        "content": "And, when we call any method from the Calc class, it will get invoked with our debug_function."
      },
      {
        "type": "pre",
        "content": "def debug_function(func):    def wrapper(*args, **kwargs):        print(\"{0} is called with parameter {1}\".format(func.__qualname__, args[1:]))        return func(*args, **kwargs)        return wrapperdef debug_all_methods(cls):    for key, val in vars(cls).items():        if callable(val):            setattr(cls, key, debug_function(val))    return clsclass MetaClassDebug(type):    def __new__(cls, clsname, bases, clsdict):        obj = super().__new__(cls, clsname, bases, clsdict)        obj = debug_all_methods(obj)        return objclass Calc(metaclass=MetaClassDebug):    def add(self, x, y):        return x + y    def sub(self, x, y):        return x - y    def mul(self, x, y):        return x * ycalc = Calc()print(calc.add(2, 3))print(calc.sub(2, 3))print(calc.mul(2, 3))**************** output ****************Calc.add is called with parameter (2, 3)5Calc.sub is called with parameter (2, 3)-1Calc.mul is called with parameter (2, 3)6"
      },
      {
        "type": "p",
        "content": "Bingo! In the above snippet, we created a meta-class MetaClassDebug and wrote a new method which is responsible for creating an instance of class and applies our decorator function debug_function to the object (instance), which will get created for every class that inherits MetaClassDebug."
      },
      {
        "type": "p",
        "content": "Calc is inherited from MetaClassDebug, hence every method has been decorated by debug_function from debug_all_methods."
      },
      {
        "type": "p",
        "content": "This way, we can add new behavior to all the methods within a class and also control the instance creation of a class using a meta-class. We can achieve a lot with a meta-class, such as adding a method or field to class, removing a method or field from a class, and many more."
      },
      {
        "type": "p",
        "content": "I wanted you to have a quick look at meta-programming in Python, so I wasn‚Äôt able to cover all the things in this post."
      },
      {
        "type": "p",
        "content": "I hope that this article has helped you to familiarize yourself with the concept of meta-programming. Criticism is always welcome!"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T02:00:11.307272"
  },
  {
    "url": "https://medium.com/@KanakSengar/networking-and-web-apis-in-python-your-essential-guide-3f780a454c3e",
    "title": "Networking and Web APIs in Python: Your Essential Guide",
    "author": "",
    "published_date": null,
    "reading_time": "5 min read",
    "tags": [],
    "content": [
      {
        "type": "h1",
        "content": "Networking and Web APIs in Python: Your Essential Guide"
      },
      {
        "type": "p",
        "content": "Kanak Sengar"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "Today, networking and web APIs are integral parts of modern software development. Whether you‚Äôre retrieving data from an API, managing real-time connections, or handling multiple HTTP requests, Python‚Äôs libraries make these tasks approachable. In this guide, we‚Äôll explore four essential Python libraries ‚Äî Requests, aiohttp, httpx, and Socket ‚Äî along with use cases, code examples, and interactive prompts to try on your own!"
      },
      {
        "type": "h1",
        "content": "1. Requests: The Simplicity of HTTP Requests"
      },
      {
        "type": "p",
        "content": "Overview: Requests is one of the most widely used libraries for making HTTP requests in Python. Its intuitive API design makes it easy to interact with web services, download data, and handle HTTP headers. Requests hides much of the complexity, so you can quickly get data from the web with minimal setup."
      },
      {
        "type": "h2",
        "content": "Key Features of Requests:"
      },
      {
        "type": "p",
        "content": "Setting Up Requests:"
      },
      {
        "type": "pre",
        "content": "pip install requests"
      },
      {
        "type": "p",
        "content": "Try It: Make Your First API Request!"
      },
      {
        "type": "pre",
        "content": "import requestsresponse = requests.get('https://jsonplaceholder.typicode.com/todos/1')print(\"Status Code:\", response.status_code)  # Check the response statusprint(\"JSON Response:\", response.json())     # View the JSON data"
      },
      {
        "type": "p",
        "content": "Exploration: Try changing the endpoint to '/todos/2' or another resource. What data do you get back? Notice how easy it is to work with JSON data using Requests."
      },
      {
        "type": "p",
        "content": "When to Use Requests: Requests is ideal for basic HTTP interactions, fetching data from REST APIs, and single HTTP requests that don‚Äôt need to be asynchronous."
      },
      {
        "type": "p",
        "content": "Challenges of Requests:"
      },
      {
        "type": "p",
        "content": "Requests is perfect for straightforward HTTP interactions, especially when asynchronous processing isn‚Äôt necessary."
      },
      {
        "type": "h1",
        "content": "2. aiohttp: The Asynchronous Powerhouse"
      },
      {
        "type": "p",
        "content": "Overview: When you need asynchronous capabilities, aiohttp is the go-to library. It integrates seamlessly with Python‚Äôs asyncio framework, enabling non-blocking HTTP requests that are efficient for handling multiple API calls or real-time data streams. aiohttp also supports WebSocket connections, which are essential for building real-time applications."
      },
      {
        "type": "h2",
        "content": "Key Features of aiohttp:"
      },
      {
        "type": "p",
        "content": "Setting Up aiohttp:"
      },
      {
        "type": "pre",
        "content": "pip install aiohttp"
      },
      {
        "type": "p",
        "content": "Try It: Making an Async Request with aiohttp"
      },
      {
        "type": "pre",
        "content": "import aiohttpimport asyncioasync def fetch_data():    async with aiohttp.ClientSession() as session:        async with session.get('https://jsonplaceholder.typicode.com/todos/1') as response:            data = await response.json()            print(\"Data:\", data)asyncio.run(fetch_data())"
      },
      {
        "type": "p",
        "content": "Exploration: Modify the URL or try making multiple requests in one function. See how quickly aiohttp handles requests asynchronously."
      },
      {
        "type": "p",
        "content": "When to Use aiohttp: Perfect for scenarios needing concurrent requests, like scraping multiple pages, API calls in real-time applications, or WebSocket connections for two-way communication."
      },
      {
        "type": "p",
        "content": "Challenges of aiohttp:"
      },
      {
        "type": "p",
        "content": "aiohttp is perfect for high-performance, concurrent tasks, especially for applications requiring WebSocket connections or frequent API calls."
      },
      {
        "type": "h1",
        "content": "3. httpx: The Next-Generation HTTP Client"
      },
      {
        "type": "p",
        "content": "Overview: httpx is a modern library that supports both synchronous and asynchronous HTTP requests, combining the simplicity of Requests with the asynchronous power of aiohttp. With added features like HTTP/2 support and built-in retries, httpx is a great fit for advanced web API requirements."
      },
      {
        "type": "h2",
        "content": "Key Features of httpx:"
      },
      {
        "type": "p",
        "content": "Setting Up httpx:"
      },
      {
        "type": "pre",
        "content": "pip install httpx"
      },
      {
        "type": "p",
        "content": "Try It: Async Requests with httpx"
      },
      {
        "type": "pre",
        "content": "import httpximport asyncioasync def fetch_data():    async with httpx.AsyncClient() as client:        response = await client.get('https://jsonplaceholder.typicode.com/todos/1')        print(\"Response:\", response.json())asyncio.run(fetch_data())"
      },
      {
        "type": "p",
        "content": "Exploration: Try fetching multiple resources, or set up httpx in synchronous mode. Notice how the AsyncClient manages connections without blocking the code."
      },
      {
        "type": "p",
        "content": "When to Use httpx: Choose httpx when you need both sync and async functionality, HTTP/2 support, or advanced retry features for reliable requests."
      },
      {
        "type": "p",
        "content": "Quick Comparison (Requests vs. httpx): While Requests is synchronous-only, httpx provides both sync and async modes, making it suitable for applications that may require concurrent processing."
      },
      {
        "type": "p",
        "content": "Challenges of httpx:"
      },
      {
        "type": "p",
        "content": "httpx is ideal for applications requiring a combination of synchronous and asynchronous capabilities, particularly when advanced features like HTTP/2 are needed."
      },
      {
        "type": "h1",
        "content": "4. Socket: Custom Networking at the Low Level"
      },
      {
        "type": "p",
        "content": "Overview: For low-level networking, Python‚Äôs built-in socket library is a versatile tool. Unlike Requests, aiohttp, or httpx, which focus on HTTP, socket allows you to create custom TCP or UDP connections, making it ideal for chat applications, multiplayer games, and specialized network protocols."
      },
      {
        "type": "h2",
        "content": "Key Features of Socket:"
      },
      {
        "type": "p",
        "content": "Setting Up Socket: No installation is necessary, as socket is part of the Python standard library."
      },
      {
        "type": "p",
        "content": "Try It: A Simple TCP Client with Socket"
      },
      {
        "type": "pre",
        "content": "import socketdef fetch_data():    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect(('example.com', 80))    request = \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\"    s.send(request.encode())    response = s.recv(4096)    print(\"Response:\", response.decode())    s.close()fetch_data()"
      },
      {
        "type": "p",
        "content": "Exploration: Experiment by changing the host or adding custom headers. Socket requires a bit more setup, but it‚Äôs flexible for creating your own networking solutions."
      },
      {
        "type": "p",
        "content": "When to Use Socket: Socket is best suited for real-time applications, like chat servers or multiplayer games, or any application that requires a custom protocol."
      },
      {
        "type": "p",
        "content": "Challenges of Socket:"
      },
      {
        "type": "p",
        "content": "Socket is best for custom networking tasks like real-time applications, multiplayer games, and specialized protocols."
      },
      {
        "type": "h1",
        "content": "Comparison of Networking Libraries"
      },
      {
        "type": "h1",
        "content": "Choosing the Right Library"
      },
      {
        "type": "p",
        "content": "The choice depends on your project‚Äôs specific needs:"
      },
      {
        "type": "h1",
        "content": "Resources to Deepen Your Knowledge"
      },
      {
        "type": "p",
        "content": "Ready to dive deeper? These resources will help you master Python‚Äôs networking libraries:"
      },
      {
        "type": "p",
        "content": "These libraries allow Python developers to handle networking in everything from basic HTTP requests to complex, custom protocols. Start experimenting, follow the resources, and take your networking skills to the next level!"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T02:00:14.564608"
  },
  {
    "url": "https://medium.com/@ayushmandurgapal/data-visualization-using-python-1f0b032ff2db",
    "title": "Data Visualization using Python",
    "author": "",
    "published_date": null,
    "reading_time": "15 min read",
    "tags": [
      "Data Visualization",
      "Python",
      "Matplotlib",
      "Seaborn",
      "Plotly"
    ],
    "content": [
      {
        "type": "h1",
        "content": "Data Visualization using Python"
      },
      {
        "type": "p",
        "content": "Ayushman Durgapal"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "1"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "blockquote",
        "content": "‚ÄúVisualization gives you answers to questions you didn‚Äôt know you had.‚Äù‚Äì Ben Schneiderman"
      },
      {
        "type": "p",
        "content": "‚ÄúVisualization gives you answers to questions you didn‚Äôt know you had.‚Äù"
      },
      {
        "type": "p",
        "content": "‚Äì Ben Schneiderman"
      },
      {
        "type": "p",
        "content": "Data Visualization is the art of presenting complex and unorganized data into a form that is easier to comprehend, visually appealing, and actionable. It can be a mammoth task to make sense out of data in the form of tables. This is when visualizing it in the form of charts, graphs, and maps becomes important. A clear representation of data makes it easy to understand the patterns, trends, and outliers in the data."
      },
      {
        "type": "p",
        "content": "There can be a lot of graphs and charts to represent the data. But what type of visual would be best suited for a particular type of data? This is the question that we will try to answer in the article. This article mainly focuses on visualizing data through Python. There can be many useful data visualization tools like Tableau, PowerBI, Qlikview, etc. to do the same. There are a lot of libraries that can be used in Python to visualize data. Some of the most common are matplotlib, seaborn, plotly, GGPlot, Bokeh, Geoplotlib, and PyGal. Here, we will mostly be focussing on the matplotlib, seaborn, and plotly for our visualizations."
      },
      {
        "type": "p",
        "content": "Let‚Äôs now get into the details of different types of visualizations and when and how should we use them:"
      },
      {
        "type": "p",
        "content": "1- Line Chart"
      },
      {
        "type": "p",
        "content": "It is one of the most common charts that is used to observe a single or multiple variables with the change of another variable. Basically, it is used in trend analysis and time series analysis. It is always a best practice to use line charts with continuous data, as the value of one variable can be found by projecting the other variable on the line at any point. You can use the following code to make a line chart in matplotlib -"
      },
      {
        "type": "p",
        "content": "Importing the libraries"
      },
      {
        "type": "p",
        "content": "These are all the libraries we would need for the graphs we create in this article."
      },
      {
        "type": "pre",
        "content": "import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as snsimport plotly as pyimport plotly.express as pximport plotly.graph_objects as go"
      },
      {
        "type": "p",
        "content": "Getting the data"
      },
      {
        "type": "pre",
        "content": "Data = {'Year': [1920,1930,1940,1950,1960,1970,1980,1990,2000,2010, 2020],        'Unemployment_Rate': [9.8,12,8,7.2,6.9,7,6.5,6.2,5.5,6.3, 7.9]       }df = pd.DataFrame(Data, columns = ['Year', 'Unemployment_Rate'])"
      },
      {
        "type": "p",
        "content": "Creating the chart using matplotlib"
      },
      {
        "type": "pre",
        "content": "plt.plot(df.Year, df.Unemployment_Rate, marker = 'o', color = 'black',          linewidth = 0.9, linestyle = '--',         markeredgecolor = 'blue',          markeredgewidth = '2.0',          markerfacecolor = 'red', markersize = 7.0)plt.title('Trend of unemployment rate', color = 'Blue', size = 14)plt.xlabel('Year', size = 14)plt.ylabel('Unemployment Rate', size = 14)plt.style.use('fivethirtyeight')plt.grid(True)plt.xticks(rotation = 30)plt.show()"
      },
      {
        "type": "p",
        "content": "2- Bar Chart"
      },
      {
        "type": "p",
        "content": "A bar chart is also one of the most used charts. It uses bars to show the change in the value of a particular variable wrt the other. This type of chart is generally used discrete or categorical data. A bar chart can be horizontal or vertical."
      },
      {
        "type": "p",
        "content": "Now, in some cases we might need to add another categorical variable and show its variation our visualization. In such cases we use a stacked bar chart. Different bars, representing data of different categories present in that variable, are stacked one on top of the other. The total length of the bar is equal to the sum of the values of all different categories in that variable. A stacked bar chart would show how the data is distributed among different categories."
      },
      {
        "type": "p",
        "content": "Data Used ‚Äî"
      },
      {
        "type": "p",
        "content": "Here, I am using a students performance dataset from Kaggle ‚Äî"
      },
      {
        "type": "p",
        "content": "Creating bar chart with matplotlib"
      },
      {
        "type": "pre",
        "content": "fig = plt.figure(figsize=(5, 6))plt.style.use('fivethirtyeight')plt.bar(    x=df_st[\"race/ethnicity\"].unique(),    height=df_st[\"race/ethnicity\"].value_counts().to_list(),    color='blue',         # Set the color of the bars    edgecolor='black',    # Set the color of the bar edges    linewidth=1.5,        # Set the width of the bar edges    alpha=0.8             # Set the transparency of the bars)plt.xlabel('Race/Ethnicity', fontsize=14, fontweight='bold')  # Set the x-axis label with font size and styleplt.ylabel('Count', fontsize=14, fontweight='bold')           # Set the y-axis label with font size and styleplt.title('Race/Ethnicity Counts', fontsize=16, fontweight='bold')  # Set the chart title with font size and styleplt.xticks(fontsize=12, rotation = 45)    # Set the font size of the x-axis tick labelsplt.yticks(fontsize=12)    # Set the font size of the y-axis tick labelsplt.grid(True, linestyle='--', linewidth=0.5, alpha=0.5, color = \"black\")  # Display gridlines with a dashed style and reduced opacityplt.show()"
      },
      {
        "type": "p",
        "content": "Creating stacked bar chart with matplotlib"
      },
      {
        "type": "pre",
        "content": "grouped_data = df_st.groupby(['race/ethnicity', 'gender']).size().unstack()fig = plt.figure(figsize=(5, 6))plt.style.use('fivethirtyeight')plt.bar(    x=grouped_data.index,    height= grouped_data[\"female\"],    label = \"Female\",    color='orange',      # Set the color of the bars    edgecolor='black',    # Set the color of the bar edges    linewidth=1.5,        # Set the width of the bar edges    alpha=0.8             # Set the transparency of the bars)plt.bar(    x=grouped_data.index,    height= grouped_data[\"male\"],    bottom = grouped_data[\"female\"],    label = \"Male\",    color='blue',      # Set the color of the bars    edgecolor='black',    # Set the color of the bar edges    linewidth=1.5,        # Set the width of the bar edges    alpha=0.8             # Set the transparency of the bars)plt.xlabel('Race/Ethnicity', fontsize=14, fontweight='bold')  # Set the x-axis label with font size and styleplt.ylabel('Count', fontsize=14, fontweight='bold')           # Set the y-axis label with font size and styleplt.title('Race/Ethnicity Counts', fontsize=16, fontweight='bold')  # Set the chart title with font size and styleplt.xticks(fontsize=12, rotation = 45)    # Set the font size of the x-axis tick labelsplt.yticks(fontsize=12)    # Set the font size of the y-axis tick labelsplt.grid(True, linestyle='--', linewidth=0.5, alpha=0.5, color = \"black\")# Display gridlines with a dashed style and reduced opacityplt.legend()plt.show()"
      },
      {
        "type": "p",
        "content": "3- Area Chart"
      },
      {
        "type": "p",
        "content": "Area charts are quite similar to line charts except for the fact that the area under the line and x-axis is shaded with a color. This type of chart is effective in doing trend and time series analysis. However, in case of more than one category it becomes a little difficult to observe as the areas overlap. In this case it is advisable to add transparency to the charts for proper visuals."
      },
      {
        "type": "p",
        "content": "Unlike line charts, we can also plot a stacked area chart. Just like stacked column charts, stacked area charts also how different categories of a variable vary over time."
      },
      {
        "type": "p",
        "content": "Here, I am using the same Unemployment Rate dataset used for line chart."
      },
      {
        "type": "p",
        "content": "Creating Area Chart in matplotlib"
      },
      {
        "type": "pre",
        "content": "fig = plt.figure(figsize = (5,4))plt.fill_between(df['Year'], df['Unemployment_Rate'], color='skyblue', alpha=0.7)plt.plot(df['Year'], df['Unemployment_Rate'], color='skyblue', linewidth = 2)plt.xlabel(\"Year\", size = 10)plt.ylabel(\"Unemployment Rate\", size = 10)plt.title(\"Unemployment Rate Trend\", size = 12)"
      },
      {
        "type": "p",
        "content": "4- Box Plots"
      },
      {
        "type": "p",
        "content": "This plot is used to get statistical information about distribution. It shows the median, maximum, minimum, 25th percentile and 75th percentile values. It is also good to explore outliers in the dataset. The diagram below shows a boxplot:"
      },
      {
        "type": "p",
        "content": "The line in the middle of the box is the 50th percentile value or the median value. The difference between first quartile (Q1) and third quartile (Q3) is called the Interquartile Range (IQR). Q1‚Äì(1.5*IQR) and Q3 + (1.5*IQR) form the two whiskers of the boxplot. Values beyond these are considered to be outliers."
      },
      {
        "type": "p",
        "content": "I have used the Student Performance dataset to demonstrate the code below ‚Äî"
      },
      {
        "type": "pre",
        "content": "green_diamond = dict(markerfacecolor='g', marker='o')fig = plt.figure(figsize = (4,3))_bp = plt.boxplot(    [df_st[df_st['gender'] == 'male']['reading score'],     df_st[df_st['gender'] == 'female']['reading score']],    labels=['Male', 'Female'],     notch = True,     flierprops = green_diamond,    vert = True,     patch_artist = True)_colors = ['blue', 'red']  for patch, color in zip(_bp['boxes'], _colors): patch.set_facecolor(color)     plt.xlabel('Gender', size= 8)plt.ylabel('Reading Score', size = 8)plt.title('Reading Score by Gender', size= 10)plt.grid(True)plt.show()"
      },
      {
        "type": "p",
        "content": "5- Scatter Plot"
      },
      {
        "type": "p",
        "content": "In a scatter plot, the data is scattered between the two axes. These type of plots are basically used to study the correlation between the two variables. If one variable increases or decreases with other, they are positively correlated. If one variable increases as the other decreases and vice versa, they are negatively correlated. If there is no such relation, they aren‚Äôt related. It is one of the most common charts to observe the relation between two variables."
      },
      {
        "type": "p",
        "content": "If there are more than one categories in a variable, they can be shown by different colors. We can also plot a trend line, extrapolating which we can predict the future values."
      },
      {
        "type": "p",
        "content": "Here, I have the famous iris dataset."
      },
      {
        "type": "p",
        "content": "Creating Scatter Plot in matplotlib"
      },
      {
        "type": "pre",
        "content": "plt.scatter(iris.SepalLengthCm, iris.PetalLengthCm, marker = \"o\",            color = \"red\", linewidths = 1, edgecolors = \"red\", s = 10)plt.style.use('fivethirtyeight')plt.xlabel(\"Sepal Length in cm\", size = 10, color = \"black\")plt.ylabel(\"Petal Length in cm\", size = 10, color = \"black\")plt.title(\"Sepal Length vs Petal Length\", size =12, color = \"black\")plt.xticks(color = \"black\")plt.yticks(color = \"black\")plt.grid(color = \"grey\", alpha = 0.2)plt.show()"
      },
      {
        "type": "p",
        "content": "Creating a scatter plot with different categories"
      },
      {
        "type": "pre",
        "content": "sns.set_style(\"ticks\")sns.scatterplot(x = iris.SepalLengthCm, y = iris.PetalLengthCm,                 hue = iris.Species, palette = \"mako\")plt.xlabel(\"Sepal Length in cm\", size = 10, color = \"black\")plt.ylabel(\"Petal Length in cm\", size = 10, color = \"black\")plt.title(\"Sepal Length vs Petal Length\", size =12, color = \"black\")plt.xticks(color = \"black\")plt.yticks(color = \"black\")plt.legend(loc = \"lower right\")plt.show()"
      },
      {
        "type": "p",
        "content": "6- Bubble Chart"
      },
      {
        "type": "p",
        "content": "A bubble chart is similar to a scatter plot but is used when we need to observe the relation between three variables. In this chart, the size of the bubble corresponds to the third variable."
      },
      {
        "type": "p",
        "content": "Creating Bubble Chart in matplotlib"
      },
      {
        "type": "pre",
        "content": "from sklearn.preprocessing import MinMaxScalersizes = iris['PetalWidthCm']/iris['PetalWidthCm'].max()# Here, the size of the bubble will show the Petal Widthplt.figure()plt.scatter(iris.SepalLengthCm, iris.PetalLengthCm, marker = \"o\",             color = \"red\", linewidths = 1, edgecolors = \"red\",             s= sizes*250, alpha = 0.5)plt.style.use('fivethirtyeight')plt.xlabel(\"Sepal Length in cm\", size = 10, color = \"black\")plt.ylabel(\"Petal Length in cm\", size = 10, color = \"black\")plt.title(\"Sepal Length vs Petal Length\", size =12, color = \"black\")plt.xticks(color = \"black\")plt.yticks(color = \"black\")plt.grid(color = \"grey\", alpha = 0.2)plt.show()"
      },
      {
        "type": "p",
        "content": "7- Histogram"
      },
      {
        "type": "p",
        "content": "This type of chart is used to observe the frequency distribution of a variable. The variable is divided into different intervals and the length of bars of the histogram show the frequency of the variable for a particular interval. Histograms can be used to observe discrete as well as continuous data. It is a great way to see how the values are being distributed and how skewed is the dataset."
      },
      {
        "type": "p",
        "content": "We will use the same iris dataset for creating this Histogram"
      },
      {
        "type": "p",
        "content": "Creating Histogram in matplotlib"
      },
      {
        "type": "pre",
        "content": "# If bins of specific width are neededbin_width = 0.2bins = int((iris.SepalWidthCm.max()-iris.SepalWidthCm.min())/bin_width)plt.style.use('classic')plt.hist(iris.SepalWidthCm, bins = bins, color = \"yellow\", alpha = 0.6,          orientation = \"vertical\", rwidth = 1)plt.xlabel(\"Sepal Width in cm\", size = 12, color = \"black\")plt.ylabel(\"Frequency\", size = 12, color = \"black\")plt.title(\"Histogram for Sepal Length\", size =15, color = \"black\")plt.xticks(color = \"black\")plt.yticks(color = \"black\")plt.show()"
      },
      {
        "type": "p",
        "content": "8- Pie Chart"
      },
      {
        "type": "p",
        "content": "A Pie chart is a circular chart that is divided into different parts (representing slices of a pie) and each part represents a category of the variable. This type of chart is useful in showing proportions of different categories. It is a great representation to analyse part-to-whole relationship."
      },
      {
        "type": "p",
        "content": "Pie Charts are ideal to visualize categorical data, but can also be used for discrete data (eg. shoe size, number of countries visited, etc.). But the chart can get cluttered and difficult to read if the values in a discrete data are a lot. For example, the percentage contribution of different countries to the world economy. This will have a lot of values. In such a case, the numbers can be grouped and each slice of the pie would represent that group. This would make it easier to understand, but yes, it would affect the quality of representation in case someone wants to fetch information about the exact contribution of each country."
      },
      {
        "type": "p",
        "content": "Here, we are using the Student Performance dataset."
      },
      {
        "type": "pre",
        "content": "explode = (0.1,0,0,0,0)colors = sns.color_palette('pastel')[0:5]plt.style.use(\"fivethirtyeight\")ethnicity_counts = df_st[\"race/ethnicity\"].value_counts()plt.pie(df_st[\"race/ethnicity\"].value_counts(),         labels = df_st[\"race/ethnicity\"].value_counts().index,         autopct=lambda pct: f\"{pct:.1f}%\\n({int(pct/100*ethnicity_counts.sum())})\",        colors = colors,        pctdistance = 1.2,        labeldistance  =0.5,        explode =explode,        shadow = True)plt.title(\"Distribution of Different Ethnicties in the Class\", size = 12)"
      },
      {
        "type": "p",
        "content": "9- Violin Plot"
      },
      {
        "type": "p",
        "content": "A Violin plot is similar to a box plot. Along with the statistical information, it also provides a kernel density plot of the data. A kernel density plot basically shows the distribution of data. So, whenever we need to observe the distribution along with the statistics, such a plot comes in handy. Like boxplot, violin plots can also be used with numerical data only."
      },
      {
        "type": "p",
        "content": "Using the same Student Performance dataset, let‚Äôs create a Violin Plot in matplotlib."
      },
      {
        "type": "pre",
        "content": "colors = ['green', 'salmon']plt.figure(figsize = (5,7))violin_parts = plt.violinplot([df_st[df_st['gender'] == 'male']['reading score'],              df_st[df_st['gender'] == 'female']['reading score']],               showmeans = True, showmedians = True,              widths = 0.1,              positions = [1,1.4],              vert = True,              showextrema = True)for pc, color in zip(violin_parts['bodies'], colors):    pc.set_facecolor(color)labels = [\"Male\", \"Female\"]data = [df_st[df_st['gender'] == 'male']['reading score'], df_st[df_st['gender'] == 'female']['reading score']]    plt.text(1,16,\"Male\" ,ha='center', va = \"top\")plt.text(1.4,16,\"Female\",ha='center', va = \"top\")plt.xlabel('Gender', size= 12)plt.ylabel('Reading Score', size = 12)plt.title('Reading Score by Gender', size= 14)plt.xticks([])plt.grid(True)plt.show()"
      },
      {
        "type": "p",
        "content": "But, this is a lot of code and the results are not that appealing. Let‚Äôs try seaborn."
      },
      {
        "type": "pre",
        "content": "sns.violinplot(data = df_st, y = df_st[\"reading score\"], x = df_st[\"gender\"],               linewidth =1, scale = \"count\",              width = 0.5, inner = \"quartile\", orient = \"v\", palette = \"Set2\")plt.xlabel('Gender', size= 14)plt.ylabel('Reading Score', size = 14)plt.title('Reading Score by Gender', size= 15)plt.xticks([])plt.grid(True)plt.show()"
      },
      {
        "type": "p",
        "content": "10- HeatMap"
      },
      {
        "type": "p",
        "content": "A heatmap is basically a two-dimensional plot which is mainly used to analyze the correlation between the different fields in a dataset. A heatmap is divided in square boxes that are colored with a specific color representing the correlation between the two fields it corresponds to. The extreme colors represent a strong positive or negative correlation."
      },
      {
        "type": "p",
        "content": "Creating a heatmap using seaborn"
      },
      {
        "type": "pre",
        "content": "correlation_matrix = iris.corr()sns.heatmap(correlation_matrix, annot = True, cmap = \"viridis\",             fmt = \"0.2f\", linewidth = 0.5)plt.title('Correlation Heatmap')plt.xlabel('Features')plt.ylabel('Features')plt.xticks(rotation = 45)plt.show()"
      },
      {
        "type": "p",
        "content": "11- Treemap"
      },
      {
        "type": "p",
        "content": "A treemap divides a rectangle into several subparts and these subparts represent different categories of the variable. The size of the subparts correspond to the values of the categories. So, just like pie-chart, it is effective in showing part-to-whole relationships. But it is used mostly when we just need to explore the trend rather than focusing on precision. Also, in some cases the color intensity of different rectangles in a treemap can be used to represent another variable."
      },
      {
        "type": "p",
        "content": "This type of visualization is also useful when there is some hierarchy in the categorical data using nested rectangles."
      },
      {
        "type": "p",
        "content": "Here, we will use plotly and the Student Performance dataset ot create a Treemap."
      },
      {
        "type": "pre",
        "content": "import plotly.express as pxfig = px.treemap(df_st, path=['race/ethnicity'], values='reading score',                  hover_data = [\"race/ethnicity\", \"reading score\"],                 width=800, height=500)# Customize the treemapfig.update_layout(title='Treemap of Reading Scores by Race/Ethnicity')# Show the treemapfig.show()"
      },
      {
        "type": "p",
        "content": "12- KDE Plot"
      },
      {
        "type": "p",
        "content": "A KDE Plot or Kernel Density Estimate plot is used to visualize the probability density of a continuous variable. We can plot probability density at different values of the variable or even the probability density against different values of some other variable. The latter one is known as a 2-dimensional KDE Plot which helps us to analyze the relation between two variables."
      },
      {
        "type": "p",
        "content": "This type of plot is best suited for continuous data. It might be used be discrete data as well, but it won‚Äôt be accurate at all points."
      },
      {
        "type": "p",
        "content": "Creating univariate KDE Plot using Seaborn"
      },
      {
        "type": "pre",
        "content": "sns.kdeplot(x=iris[\"SepalLengthCm\"], hue = iris[\"Species\"],             linewidth = 0.5, fill = True, multiple = \"layer\", cbar = True,            palette = \"crest\", alpha = 0.4)"
      },
      {
        "type": "p",
        "content": "Creating Bivariate KDE Plot using Seaborn"
      },
      {
        "type": "pre",
        "content": "sns.kdeplot(x=iris[\"SepalLengthCm\"], y = iris[\"PetalLengthCm\"], linewidth = 0.5, fill = True, multiple = \"layer\", cbar = False,           palette = \"crest\", alpha = 0.7)"
      },
      {
        "type": "p",
        "content": "13- WordCloud"
      },
      {
        "type": "p",
        "content": "A WordCloud is a representation that can be used only with text data. This type of visualization gives us information about the context of the data. The size of different words represents the frequency or importance of those words. Such visualizations are quite important in analyzing data from social networking websites and also exploring data before performing Natural Language Processing."
      },
      {
        "type": "p",
        "content": "Creating WordCloud in Python"
      },
      {
        "type": "pre",
        "content": "from wordcloud import WordCloud# Generate random datacategories = ['Madrid', 'New York', 'Mumbai', 'Paris', 'Toronto', 'Tokyo', 'London']num_data_points = 500data = np.random.choice(categories, num_data_points)# Create a DataFramedf = pd.DataFrame({'Category': data})# Count the occurrences of each categorycategory_counts = df['Category'].value_counts()# Generate word cloud based on category countswordcloud = WordCloud(width=800, height=400, background_color='white',                       colormap='viridis', max_font_size=100, max_words=50,                       margin = 5, prefer_horizontal = 0.7)wordcloud.generate_from_frequencies(category_counts)# Display the word cloudplt.figure(figsize=(10, 6))plt.imshow(wordcloud, interpolation='bilinear')plt.axis('off')plt.show()"
      },
      {
        "type": "p",
        "content": "14- Count Plot"
      },
      {
        "type": "p",
        "content": "A CountPlot is basically used to show the count of the number of observations of a categorical variable in a dataset. This type of plot can only be used with categorical variables. It can also be used to show counts for two categorical variables as shown in the figure -"
      },
      {
        "type": "p",
        "content": "Here, we will use the Student Performance dataset."
      },
      {
        "type": "p",
        "content": "Creating Count Plot in seaborn"
      },
      {
        "type": "pre",
        "content": "sns.countplot(data = df_st, x = \"race/ethnicity\", hue = \"gender\",               palette = \"plasma\")"
      },
      {
        "type": "p",
        "content": "15- Joint Plot"
      },
      {
        "type": "p",
        "content": "A Joint Plot plot is mainly a mix of bivariate and univariate plots. They are helpful in analyzing the relation between 2 variables as well as their individual variations (univariate analysis). The univariate graph is on the margin, whereas the bivariate plot is between the 2 axes. We can have kdeplots, scatterplots, etc. to analyze the relation between two variables."
      },
      {
        "type": "p",
        "content": "We will use the iris dataset to create a Joint Plot."
      },
      {
        "type": "pre",
        "content": "g = sns.jointplot(data = iris, x= \"SepalWidthCm\", y=\"PetalWidthCm\",                   hue = \"Species\", height = 7,                  palette = \"colorblind\", marker = \"o\")ax = g.ax_joint# Move the legend to a specific locationax.legend(title=\"Sex\", loc=\"upper left\", fontsize = 10)"
      },
      {
        "type": "p",
        "content": "16- DistPlot"
      },
      {
        "type": "p",
        "content": "A distplot is used to plot a histogram along with the kernel density estimate of a particular variable. Such a plot is used with discrete or continuous data. This function basically combines a histogram and kdeplot."
      },
      {
        "type": "p",
        "content": "Creating DistPlot in seaborn"
      },
      {
        "type": "pre",
        "content": "sns.distplot(iris[\"SepalWidthCm\"], bins = 25, kde = True,              rug = True, color = \"green\", hist_kws = {\"alpha\":0.3},              kde_kws = {\"linewidth\":2})"
      },
      {
        "type": "p",
        "content": "17- PairPlot"
      },
      {
        "type": "p",
        "content": "A paiplot, as the name suggests, plots pairwise bivariate distributions to show relation of each variable with all other variables in a dataset. It is very useful for exploring the data and analyzing relations between different variables. Since it creates a bivariate plot of each variable with others, the total number of plots created are n¬≤ where n is the number of variables."
      },
      {
        "type": "p",
        "content": "Creating PairPlot in seaborn using iris dataset"
      },
      {
        "type": "pre",
        "content": "sns.pairplot(data=iris, hue = \"Species\", corner = False,              diag_kws = {\"linewidth\":1, \"fill\":True},              plot_kws = dict(marker = \"o\"))# kind{‚Äòscatter‚Äô, ‚Äòkde‚Äô, ‚Äòhist‚Äô, ‚Äòreg‚Äô}"
      },
      {
        "type": "p",
        "content": "18- RegPlot"
      },
      {
        "type": "p",
        "content": "A regplot or regression plot is used to observe the relationship between two variables. It fits a linear or a non-linear regression model to the data and plots a trend line that shows how the two variables are related. We can choose the order of the trend line. We can also specify a confidence interval and this will be indicated by translucent bands around the regression line."
      },
      {
        "type": "p",
        "content": "Creating regplot using seaborn"
      },
      {
        "type": "pre",
        "content": "sns.regplot(data = iris, x=\"SepalLengthCm\", y=\"PetalLengthCm\",             line_kws = dict(linewidth = 1), ci = 95, scatter = True,             color = \"red\")plt.grid(True)"
      },
      {
        "type": "p",
        "content": "19- 3D Plots"
      },
      {
        "type": "p",
        "content": "A three dimensional plot is used when we need to observe relation between three numerical variables. To observe relation between two numeric and one categorical variable, we can use a 2-D plot with ‚Äòhue‚Äô parameter. But for more than 3 numeric variables, a 3-D plot is needed. We can plot scatter plots, surface plots, contour plots, etc. to show the variation."
      },
      {
        "type": "p",
        "content": "Creating 3D Plots in Python"
      },
      {
        "type": "pre",
        "content": "from mpl_toolkits.mplot3d import Axes3Dfig = plt.figure(figsize = (20,20))plt.style.use(\"classic\")ax = fig.add_subplot(111, projection='3d')ax.scatter(iris[\"PetalWidthCm\"], iris[\"SepalWidthCm\"],iris[\"PetalLengthCm\"], c = \"red\")ax.set_xlabel(\"PetalWidth in cm\", fontsize = 20)ax.set_ylabel(\"SepalWidth in cm\", fontsize = 20)ax.set_zlabel(\"PetalLength in cm\", fontsize = 20)"
      },
      {
        "type": "p",
        "content": "These were almost all the different types of visualizations that can be created using different libraries in Python. Having a good knowledge of these visualizations and how they are created helps a lot in analyzing and presenting our data clearly, as it is said, ‚ÄúA picture is worth a thousand words‚Äù. You can access the Python codes for these different visuals on my GitHub."
      },
      {
        "type": "p",
        "content": "Cheers!"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T02:00:17.265885"
  },
  {
    "url": "https://pytechacademy.medium.com/exploring-testing-and-debugging-in-python-a-comprehensive-guide-309ee4e14b37",
    "title": "Exploring Testing and Debugging in Python: A Comprehensive Guide",
    "author": "Mastodon",
    "published_date": null,
    "reading_time": "4 min read",
    "tags": [],
    "content": [
      {
        "type": "p",
        "content": "Member-only story"
      },
      {
        "type": "h1",
        "content": "Exploring Testing and Debugging in Python: A Comprehensive Guide"
      },
      {
        "type": "p",
        "content": "Pytech Academy"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "Testing and debugging are essential components of the software development process. They ensure that your code is robust, reliable, and free from errors. Python offers a range of tools and frameworks that make testing and debugging an integral part of your development workflow. In this article, we‚Äôll dive into the world of testing and debugging in Python, exploring their significance and demonstrating how to use popular tools like unittest, pytest, pdb, and coverage."
      },
      {
        "type": "h2",
        "content": "Python-fundamentals/11.TestingDebugging at main ¬∑ PytechAcademy/Python-fundamentals"
      },
      {
        "type": "h3",
        "content": "Welcome to our public GitHub repository focused on Python fundamentals! Here, you'll find a treasure trove of‚Ä¶"
      },
      {
        "type": "p",
        "content": "github.com"
      },
      {
        "type": "p",
        "content": "Built-in Testing Framework ‚Äî unittest"
      },
      {
        "type": "p",
        "content": "Python‚Äôs built-in unittest framework simplifies unit testing by providing a test discovery mechanism and assertion methods."
      },
      {
        "type": "p",
        "content": "Let's consider a simple example:"
      },
      {
        "type": "pre",
        "content": "# calculator.py‚Äãdef add(a, b):    return a + b"
      },
      {
        "type": "pre",
        "content": "# test_calculator.py‚Äãimport unittestfrom calculator import add‚Äãclass TestCalculator(unittest.TestCase):    def test_add(self):        self.assertEqual(add(2, 3), 5)        self.assertEqual(add(-1, 1), 0)‚Äãif __name__ == '__main__':    unittest.main()"
      },
      {
        "type": "p",
        "content": "A Powerful Alternative ‚Äî pytest"
      },
      {
        "type": "p",
        "content": "pytest is a popular testing framework that offers concise syntax and powerful features. The same calculator example can be written as:"
      },
      {
        "type": "pre",
        "content": "# test_calculator_1.py‚Äãfrom calculator import add‚Äãdef test_add():    assert add(2, 3) == 5    assert add(-1, 1) == 0"
      },
      {
        "type": "p",
        "content": "Run pytest <folderpath> in the terminal‚Äî by default, it checks for tests folder or files starting with test_ and performs the test"
      },
      {
        "type": "p",
        "content": "Python Debugger ‚Äî pdb"
      },
      {
        "type": "p",
        "content": "Python‚Äôs built-in debugger, pdb, helps you step through your code and examine variables. Let's consider an example where we need to debug a function:"
      },
      {
        "type": "pre",
        "content": "def divide(a, b):    result = a / b    return result"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T02:00:20.458486"
  },
  {
    "url": "https://medium.com/@alensabu12xtz/python-secure-coding-practices-3c11ad5536f6",
    "title": "Python Secure Coding Practices",
    "author": "",
    "published_date": null,
    "reading_time": "3 min read",
    "tags": [],
    "content": [
      {
        "type": "p",
        "content": "Member-only story"
      },
      {
        "type": "h1",
        "content": "Python Secure Coding Practices"
      },
      {
        "type": "p",
        "content": "Alen Sabu"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "Securing your code is more important that writing a lot of code."
      },
      {
        "type": "h1",
        "content": "1. Always Avoid Hardcoding of API Keys and Important Credentials"
      },
      {
        "type": "p",
        "content": "API keys and secret credentials should be stored in .env file. We can load them using load_dotenv( ). Below is an example of storing an API_KEY:-"
      },
      {
        "type": "pre",
        "content": ".envAPI_KEY = \"YOUR API KEY\""
      },
      {
        "type": "pre",
        "content": "from dotenv import load_dotenvimport osload_dotenv()API_KEY = os.getenv(\"API_KEY\")"
      },
      {
        "type": "p",
        "content": "In your python file you can call the API_KEY as mentioned above. Always remember use .gitignore to exclude .env files from commits."
      },
      {
        "type": "h1",
        "content": "2. Use Virtual Environments"
      },
      {
        "type": "p",
        "content": "This is a security practice for Python not only because it adds another layer of security to your program but also because it tidies up your development environment. It makes it easier to find the files you need, rather than having them all exist in a single folder you must trawl through any time you need to update a single component."
      },
      {
        "type": "p",
        "content": "Setting up virtual environments is a strong, secure coding practice because it helps avoid collisions and conflicts between libraries. Virtual environments also allow you to more easily find, contain, and correct malicious packages, isolating incidents rather than allowing them to affect your entire application."
      },
      {
        "type": "h1",
        "content": "3. Implement Input Validation and Sanitization"
      },
      {
        "type": "p",
        "content": "User inputs are among the most dangerous areas of your software because they can be the vehicle for a software injection attack. Inserting a simple command can turn your authorization check into a point for administrative access to your web portal."
      },
      {
        "type": "pre",
        "content": "from pydantic import BaseModel, Fieldclass UserInput(BaseModel):    username: str = Field(min_length=3, max_length=50, regex=\"^[a-zA-Z0-9_]+$\")"
      },
      {
        "type": "p",
        "content": "The key to protecting your Python-based project is safe from attacks using input data is to sanitize the input. Check every input and create strict rules defining which inputs are valid, along with parameters for allowed combinations and acceptable character sequences."
      },
      {
        "type": "p",
        "content": "However, there‚Äôs a balance to be had. Some platforms limit the special characters people can use in their passwords. Input sanitization allows you to strike a balance that helps prevent injection attacks while still allowing users to have strong credentials."
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T02:00:23.150379"
  },
  {
    "url": "https://medium.com/@miqui.ferrer/python-packaging-best-practices-4d6da500da5f",
    "title": "Python Packaging Best Practices",
    "author": "",
    "published_date": null,
    "reading_time": "8 min read",
    "tags": [
      "Python",
      "Packaging"
    ],
    "content": [
      {
        "type": "h1",
        "content": "Python Packaging Best Practices"
      },
      {
        "type": "p",
        "content": "mic"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "10"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "The best way to share your Python project and let others install it is by building and distributing a package."
      },
      {
        "type": "p",
        "content": "For example, to share a library for other developers to use in their application, or for development tools like ‚Äòpy.test‚Äô."
      },
      {
        "type": "p",
        "content": "An advantage of this method of distribution is its well established ecosystem of tools such as PyPI and pip, which make it easy for other developers to download and install your package either for casual experiments, or as part of large, professional systems."
      },
      {
        "type": "p",
        "content": "Packaging in this context means 2 things: Building a package + distributing the package."
      },
      {
        "type": "p",
        "content": "In this article, I‚Äôll talk about the best practices when building a Python package."
      },
      {
        "type": "blockquote",
        "content": "Disclaimer: What it follows is valid if you are writing a simple package such as a pure Python package. If you have a Python package with more complicated needs, you should still use pyproject.toml-based builds and set up your project metadata as instructed below. However, you may have additional considerations when choosing a backend."
      },
      {
        "type": "p",
        "content": "Disclaimer: What it follows is valid if you are writing a simple package such as a pure Python package. If you have a Python package with more complicated needs, you should still use pyproject.toml-based builds and set up your project metadata as instructed below. However, you may have additional considerations when choosing a backend."
      },
      {
        "type": "p",
        "content": "Let‚Äôs start from the beginning though ‚Ä¶."
      },
      {
        "type": "h1",
        "content": "What is a Python package exactly?"
      },
      {
        "type": "blockquote",
        "content": "Python packages are basically bundles of Python code (usually as a compressed file archive) in a particular format that can be distributed to other people and installed by a tool like pip."
      },
      {
        "type": "p",
        "content": "Python packages are basically bundles of Python code (usually as a compressed file archive) in a particular format that can be distributed to other people and installed by a tool like pip."
      },
      {
        "type": "p",
        "content": "Nowadays there are basically 2 types of Python packages used:"
      },
      {
        "type": "p",
        "content": "Now the question is, how do we bundle our source code into a distributable Python package? Keep reading to discover how (and the best way!)."
      },
      {
        "type": "h1",
        "content": "Building standards"
      },
      {
        "type": "p",
        "content": "When one thinks about build a python package, the most frequent words popping out are setup.py, setup.cfg, setuptools, ‚Ä¶ isn‚Äôt it? Well.. these are the ‚Äúold standards‚Äù (as you can see in the python documentation here, packaging using these tools is kind of outdated)."
      },
      {
        "type": "p",
        "content": "What are the ‚Äúnew standards‚Äù then? Well‚Ä¶ give a warm welcome to pyproject.toml-based packaging!"
      },
      {
        "type": "h2",
        "content": "Building with the ‚Äúold standards‚Äù and why you should avoid that"
      },
      {
        "type": "p",
        "content": "In the ‚Äúold‚Äù way, you use a third party tool (usually setuptools) alongside the files setup.py and setup.cfg to build your package (it is basically the blue part on the diagram below)."
      },
      {
        "type": "p",
        "content": "Is is as easy as execute the following command:"
      },
      {
        "type": "p",
        "content": "Where sdist stands for source distribution and bdist_wheel, well ‚Ä¶ it stands for binary package using wheel format."
      },
      {
        "type": "p",
        "content": "So far, so easy right? But wait ‚Ä¶ what are the two main problems with the ‚Äúold‚Äù building procedure?"
      },
      {
        "type": "p",
        "content": "Remember that the ‚Äúold‚Äù way that packaging was done was with a setup.py file. You'd write a function call to a setupfunction imported from the setuptools package that defined all of your package metadata."
      },
      {
        "type": "p",
        "content": "First, this was unstructured data! You had to run this setup.py Python script to even read that data, because it was specified in code. It was more complex than it needed to be, and there were not a lot of guiderails to prevent bad practices. Because it was a script, people could write arbitrary code to dynamically do arbitrary things."
      },
      {
        "type": "p",
        "content": "Another problem with setup.py files was dealing with build-time dependencies."
      },
      {
        "type": "p",
        "content": "Consider the following situation: let's say you have a package that requires PyTorch to build with C++ and CUDA extensions. You would import things from torch in your setup.py. That meant you had to install torch in your environment before you could even pip install the package from source. Even worse, simply listing torch as a required dependency wasn't enough! Even listing torch together with your package in a requirements.txt file wasn't enough! Pip could not even check that package's dependencies: pip would need to run setup.py to get the dependencies, but setup.py couldn't run because it needs to import torch. Why do you need to install dependencies and run code just to read a bunch of static metadata? Why are there so many steps to install a Python package? In addition, if you only needed certain dependencies for building and not at runtime, it would be annoying to your users to have to install and carry around those dependencies in their environments."
      },
      {
        "type": "p",
        "content": "For this and other reasons, you should build your Python package using the new standards."
      },
      {
        "type": "h2",
        "content": "Building with the ‚Äúnew standards‚Äù"
      },
      {
        "type": "p",
        "content": "The ‚Äúnew standards‚Äù refer to a standardized way to specify package metadata (things like package name, author, dependencies) in a pyproject.toml file and the way to build packages from source code using that metadata (referred as the back-end). You often see this referred to as ‚Äúpyproject.toml-based builds.‚Äù"
      },
      {
        "type": "p",
        "content": "These 2 components are founded on 2 main PEPs (Python Enhancement Proposals), which are basically design documents about new standards or features in Python. These are PEP 517 and PEP 621."
      },
      {
        "type": "p",
        "content": "Pyproject.toml and PEP 621"
      },
      {
        "type": "p",
        "content": "The pyproject.toml file acts as a configuration file for packaging-related tools (as well as other tools). It contains package metadata such as package name, author, dependencies, etc."
      },
      {
        "type": "p",
        "content": "The pyproject.toml file is written in TOML. Three tables (TOML way to refer to a section) are currently specified, namely [build-system], [project] and [tool]. Other tables are reserved for future use (tool-specific configuration should use the [tool] table)."
      },
      {
        "type": "blockquote",
        "content": "The definition of what goes under [project] is what PEP 621 standardizes."
      },
      {
        "type": "p",
        "content": "The definition of what goes under [project] is what PEP 621 standardizes."
      },
      {
        "type": "p",
        "content": "Back-end and PEP 517"
      },
      {
        "type": "p",
        "content": "You may wonder: What is a back-end exactly?"
      },
      {
        "type": "p",
        "content": "The backend is the program that reads your pyproject.toml and actually does the work of turning your source code into a package archive that can be installed or distributed. The frontend is just a user interface (usually a command-line program) that calls the backend."
      },
      {
        "type": "p",
        "content": "The design of separating these two pieces in the build workflow means that ‚Äî in principle ‚Äî you can mix and match frontends and backends. But that‚Äôs food for another post :-)"
      },
      {
        "type": "p",
        "content": "To use a specific backend, simply include a section ‚Äúbuild-system‚Äù in your pyproject.tomlthat looks like this:"
      },
      {
        "type": "p",
        "content": "In the example above flit is used as backend. Check the documentation of your chosen backend to see how to specify it in the pyproject.toml file. Below you can see som backend examples and the way they need to be specified in the pyproject.toml file."
      },
      {
        "type": "p",
        "content": "What PEP 517 specifies are, among other things, the mandatory hooks (such as build_wheel, or build_sdist). This is essentially the interface the backend should implement."
      },
      {
        "type": "p",
        "content": "So, backends implementing the PEP 517 specification is usually referred as ‚ÄúPEP 517 backends‚Äù."
      },
      {
        "type": "p",
        "content": "Now the question is: How do I choose a build backend?"
      },
      {
        "type": "p",
        "content": "If you are writing a simple package in pure Python, you will more or less get the same outcome with any backend that is compliant with both PEP 517 ([build-system]) and PEP 621 ([project])."
      },
      {
        "type": "p",
        "content": "However, there are 2 main points in my opinion that should define which backend you choose:"
      },
      {
        "type": "p",
        "content": "Below you can see an example of a complete pyproject.toml file using PDM as backend."
      },
      {
        "type": "p",
        "content": "As you can see:"
      },
      {
        "type": "h2",
        "content": "Summary"
      },
      {
        "type": "p",
        "content": "If you want to create a Python package using the modern packaging standards:"
      },
      {
        "type": "p",
        "content": "To choose a backend to use:"
      },
      {
        "type": "blockquote",
        "content": "I personally like PDM for different reasons. It is both PEP 517 and PEP 621 compliant and it provides nice build-time features alongside a powerful front-end with sereval workflow management options."
      },
      {
        "type": "p",
        "content": "I personally like PDM for different reasons. It is both PEP 517 and PEP 621 compliant and it provides nice build-time features alongside a powerful front-end with sereval workflow management options."
      },
      {
        "type": "p",
        "content": "I hope this helped to clarify the current status of packaging standards in Python and ‚Ä¶ happy packaging! :-)"
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T02:00:25.636356"
  },
  {
    "url": "https://medium.com/@aarav.gupta9/introduction-to-machine-learning-with-python-6ea2e2615f30",
    "title": "Introduction to Machine Learning with Python",
    "author": "",
    "published_date": null,
    "reading_time": "3 min read",
    "tags": [
      "Machine Learning",
      "Python Programming",
      "Coding",
      "Artificial Intelligence",
      "Big Data"
    ],
    "content": [
      {
        "type": "h1",
        "content": "Introduction to Machine Learning with Python"
      },
      {
        "type": "p",
        "content": "Aarav Gupta"
      },
      {
        "type": "p",
        "content": "Follow"
      },
      {
        "type": "p",
        "content": "--"
      },
      {
        "type": "p",
        "content": "Listen"
      },
      {
        "type": "p",
        "content": "Share"
      },
      {
        "type": "p",
        "content": "Machine Learning (ML) is a fascinating field that empowers computers to learn from data and make predictions or decisions without being explicitly programmed. Python, with its simplicity and extensive libraries, has become the go-to language for many machine learning enthusiasts and professionals. In this blog, we‚Äôll delve into the fundamentals of machine learning and how Python is instrumental in implementing and deploying ML models."
      },
      {
        "type": "h2",
        "content": "Understanding Machine Learning"
      },
      {
        "type": "p",
        "content": "At its core, machine learning is about creating algorithms and models that enable computers to learn patterns from data. There are three main types of machine learning:"
      },
      {
        "type": "h2",
        "content": "Python and Machine Learning"
      },
      {
        "type": "p",
        "content": "Python‚Äôs popularity in the machine learning community can be attributed to several factors:"
      },
      {
        "type": "p",
        "content": "2. Ease of Use: Python‚Äôs syntax is clean and readable, making it accessible for beginners. This ease of use accelerates the development and implementation of machine learning solutions."
      },
      {
        "type": "p",
        "content": "3. Community Support: The Python community is vast and active, with a wealth of resources, forums, and documentation available. This support is invaluable for individuals seeking help or sharing insights."
      },
      {
        "type": "h1",
        "content": "Getting Started with Python for Machine Learning"
      },
      {
        "type": "h2",
        "content": "1. Install Python and Libraries"
      },
      {
        "type": "p",
        "content": "If you don‚Äôt have Python installed, download and install the latest version from the official Python website. Once installed, you can use the package manager pip to install libraries. For example:"
      },
      {
        "type": "pre",
        "content": "pip install scikit-learn pandas numpy"
      },
      {
        "type": "h2",
        "content": "2. Learn the Basics"
      },
      {
        "type": "p",
        "content": "Familiarize yourself with Python basics, data types, and control structures. Understanding concepts like lists, dictionaries, loops, and functions is crucial. For that you can read my previous blog posts on my profile."
      },
      {
        "type": "h2",
        "content": "3. Explore Datasets"
      },
      {
        "type": "p",
        "content": "Start by exploring datasets relevant to your interests. Kaggle https://www.kaggle.com/ is an excellent platform for finding diverse datasets suitable for various machine learning tasks."
      },
      {
        "type": "h2",
        "content": "4. Learn Scikit-learn"
      },
      {
        "type": "p",
        "content": "Scikit-learn is an excellent starting point for beginners. Learn how to import datasets, preprocess data, and apply machine learning algorithms. Here‚Äôs a simple example of using Scikit-learn for linear regression:"
      },
      {
        "type": "pre",
        "content": "from sklearn.model_selection import train_test_splitfrom sklearn.linear_model import LinearRegressionfrom sklearn.metrics import mean_squared_errorimport pandas as pd# Load datasetdata = pd.read_csv('your_dataset.csv')# Split data into features and target variableX = data.drop('target_variable', axis=1)y = data['target_variable']# Split data into training and testing setsX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)# Create a linear regression modelmodel = LinearRegression()# Train the modelmodel.fit(X_train, y_train)# Make predictionsy_pred = model.predict(X_test)# Evaluate the modelmse = mean_squared_error(y_test, y_pred)print(f'Mean Squared Error: {mse}')"
      },
      {
        "type": "h2",
        "content": "5. Dive into Deep Learning"
      },
      {
        "type": "p",
        "content": "Once you‚Äôre comfortable with the basics, explore deep learning using TensorFlow or PyTorch. These frameworks provide tools for building and training neural networks. Start with simple examples and gradually work your way up to more complex architectures."
      },
      {
        "type": "h1",
        "content": "Conclusion"
      },
      {
        "type": "p",
        "content": "Machine learning with Python is an exciting journey that opens up endless possibilities for solving real-world problems. Whether you‚Äôre a beginner or an experienced developer, Python‚Äôs versatility and the expansive machine learning ecosystem make it a powerful choice for turning data into actionable insights. As you embark on your machine learning journey, keep experimenting, learning, and contributing to this dynamic field."
      }
    ],
    "claps": "Unknown",
    "scraped_at": "2025-03-30T02:00:28.898865"
  }
]